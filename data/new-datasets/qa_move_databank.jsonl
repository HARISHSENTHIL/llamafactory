{"instruction": "Move modules are declared with the `module` keyword.", "input": "Which keyword is used to declare a module in Move?", "output": "`module`"}
{"instruction": "Functions are defined using the `fun` keyword.", "input": "Which keyword is used to define a function in Move?", "output": "`fun`"}
{"instruction": "Generic type parameters are specified in angle brackets.", "input": "What symbol is used to denote a type parameter in Move?", "output": "`<T>`"}
{"instruction": "Move uses `//` for single-line and `/* ... */` for multi-line comments.", "input": "How are comments written in Move?", "output": "`// single-line, /* multi-line */`"}
{"instruction": "Scripts are introduced with the `script` keyword.", "input": "Which keyword starts a script block in Move?", "output": "`script`"}
{"instruction": "The return type is indicated after `->`.", "input": "Which symbol is used to specify a function\u2019s return type in Move?", "output": "`->`"}
{"instruction": "Move uses `if` statements for conditionals.", "input": "Which keyword is used for conditional branching in Move?", "output": "`if`"}
{"instruction": "Move supports `u8`, `u64`, and `u128` as unsigned integers.", "input": "Which of the following are unsigned integer types in Move?", "output": "All of the above"}
{"instruction": "Booleans in Move are `true` and `false`.", "input": "Which boolean literals does Move recognize?", "output": "`true` and `false`"}
{"instruction": "`struct` defines a structure type.", "input": "Which keyword is used to define a structure in Move?", "output": "`struct`"}
{"instruction": "Move does not support function overloading.", "input": "Does Move support function overloading (same name, different parameters)?", "output": "No"}
{"instruction": "Curly braces define code blocks.", "input": "How are code blocks denoted in Move?", "output": "`{ ... }`"}
{"instruction": "`public` exposes a function externally.", "input": "Which keyword makes a function accessible outside its module?", "output": "`public`"}
{"instruction": "`return x;` returns `x` from a function.", "input": "How do you return a value `x` from a function in Move?", "output": "`return x;`"}
{"instruction": "Parameters are declared as `name: type`.", "input": "Where do you place the type in a function parameter in Move?", "output": "`x: u64`"}
{"instruction": "Move is not whitespace-sensitive.", "input": "Is whitespace significant (like in Python) in Move?", "output": "No"}
{"instruction": "Move uses `vector<T>` instead of fixed arrays.", "input": "Does Move have built-in fixed-length arrays?", "output": "No, only `vector<T>`"}
{"instruction": "Empty parentheses mean no parameters.", "input": "How do you define a function with no parameters?", "output": "{ ... }`"}
{"instruction": "Move supports multiple literal formats.", "input": "Which numeric literal formats does Move support?", "output": "Decimal, `0x` hex, and `0b` binary"}
{"instruction": "`abort <code>;` signals an error.", "input": "How are errors represented in Move?", "output": "By aborting with an integer error code"}
{"instruction": "`&T` is an immutable reference.", "input": "What does `&T` represent in a function parameter?", "output": "An immutable reference"}
{"instruction": "`&mut` indicates a mutable reference.", "input": "How do you denote a mutable reference type in Move?", "output": "`&mut T`"}
{"instruction": "Move has `loop` and `break`, no `while` or `for`.", "input": "Which looping construct does Move provide?", "output": "`loop` with `break`"}
{"instruction": "`break` exits the loop.", "input": "To exit a loop prematurely, you use:", "output": "`break`"}
{"instruction": "`abort <code>;` is the syntax.", "input": "How do you abort execution with error code 10?", "output": "`abort 10;`"}
{"instruction": "Move has modules and scripts at the top level.", "input": "The top-level constructs in Move are:", "output": "Modules and scripts"}
{"instruction": "`const` defines compile-time constants.", "input": "How do you declare a named constant in Move?", "output": "`const MY_CONST: u64 = 10;`"}
{"instruction": "Parameters are comma-separated.", "input": "How are multiple parameters separated in a function signature?", "output": "By commas"}
{"instruction": "Move supports multiple literal forms.", "input": "Which of the following is a valid Move integer literal?", "output": "All of the above"}
{"instruction": "Tuples allow multiple return values.", "input": "Can a Move function return multiple values?", "output": "Yes, by returning a tuple"}
{"instruction": "Booleans are lowercase.", "input": "Valid boolean literals in Move are:", "output": "`true` and `false`"}
{"instruction": "For example: `fun foo<T>(x: T) { ... }`.", "input": "Where do generic parameters appear in a Move function declaration?", "output": "After the function name in `< >`"}
{"instruction": "Type arguments go in angle brackets.", "input": "To call a generic function `foo<T>` with `T = u64` you write:", "output": "`foo<u64>(10)`"}
{"instruction": "`signer` is a special type for the transaction sender.", "input": "The `signer` type in Move represents:", "output": "An account that signed the transaction"}
{"instruction": "Fully qualified name: `address::Module::function`.", "input": "To fully qualify a function `bar` in module `M` at address `0x1`, use:", "output": "`0x1::M::bar()`"}
{"instruction": "Tuples can return multiple values from a function.", "input": "Tuples in Move are typically used for:", "output": "Returning multiple values"}
{"instruction": "`let mut` introduces a mutable variable.", "input": "To declare a mutable local variable `x` of type `u64`:", "output": "`let mut x: u64 = 0;`"}
{"instruction": "`*r` dereferences a reference.", "input": "To dereference an immutable reference `r` in Move:", "output": "`*r`"}
{"instruction": "Default visibility is private.", "input": "Without `public`, a function in a module is:", "output": "Private to that module"}
{"instruction": "`address 0x1 { module M { ... } }` sets the module's address.", "input": "The `address` block at the top of a Move file:", "output": "Specifies the module\u2019s publishing address"}
{"instruction": "No prefix means decimal.", "input": "Unprefixed integer literals in Move are interpreted as:", "output": "Decimal integers"}
{"instruction": "`==` checks equality.", "input": "Equality comparison in Move uses:", "output": "`==`"}
{"instruction": "`!=` checks inequality.", "input": "Inequality comparison in Move uses:", "output": "`!=`"}
{"instruction": "Resource types have abilities like `key`.", "input": "A resource struct in Move is indicated by:", "output": "`struct S has key`"}
{"instruction": "`struct S has store, key { ... }`.", "input": "Abilities for a struct are declared:", "output": "After `struct` using `has`"}
{"instruction": "`has` is followed by a comma-separated list of abilities.", "input": "A valid abilities annotation example is:", "output": "`struct S has key, store {}`"}
{"instruction": "Functions in the same module can be called directly by name.", "input": "To call a function `foo` defined in the same module:", "output": "`foo();`"}
{"instruction": "`self::` explicitly references the current module namespace.", "input": "To refer explicitly to a struct `S` in the current module:", "output": "`self::S`"}
{"instruction": "Move does not have a `match` construct.", "input": "Does Move have pattern matching like Rust\u2019s `match`?", "output": "No"}
{"instruction": "Hex can be uppercase or lowercase after `0x`.", "input": "A hexadecimal literal in Move can be written as:", "output": "All of the above"}
{"instruction": "Casting must be explicit with conversion functions.", "input": "To convert `u64` to `u8`, you must:", "output": "Use `u8(x)`"}
{"instruction": "These are the main control flow statements in Move.", "input": "Move\u2019s main control flow constructs are:", "output": "`if`, `else`, `loop`, `break`"}
{"instruction": "`vector<T>` is the generic vector type.", "input": "To declare a vector of `u64`:", "output": "`vector<u64>`"}
{"instruction": "`Vector::length` returns the size.", "input": "To get the length of a vector `v`:", "output": "`Vector::length(&v)`"}
{"instruction": "`push_back` appends an element.", "input": "To push an element `x` into a vector `v`:", "output": "`Vector::push_back(&mut v, x)`"}
{"instruction": "`pop_back` removes the last element.", "input": "To pop an element from the end of vector `v`:", "output": "`Vector::pop_back(&mut v)`"}
{"instruction": "`borrow` obtains an immutable reference to an element.", "input": "To read an element at index `i` from `v`:", "output": "`Vector::borrow(&v, i)`"}
{"instruction": "`borrow_mut` gives a mutable reference.", "input": "To mutate an element at index `i` in `v`:", "output": "`Vector::borrow_mut(&mut v, i)`"}
{"instruction": "Multiple immutable borrows are allowed, mutable borrows are exclusive.", "input": "Can you have multiple immutable references to the same vector element simultaneously?", "output": "Yes, multiple immutable refs are allowed"}
{"instruction": "`Vector::empty<T>()` creates an empty vector.", "input": "To create an empty `vector<u8>`:", "output": "`Vector::empty<u8>()`"}
{"instruction": "Exclusive mutable references prevent simultaneous immutable refs to the same value.", "input": "If you have a mutable reference `&mut x`, can you also have an immutable reference `&x` active at the same time to `x`?", "output": "No"}
{"instruction": "If element types are comparable, `==` works.", "input": "To compare two vectors `v1` and `v2` for equality:", "output": "Use `==` (if they\u2019re of a comparable type)"}
{"instruction": "`0b` prefix denotes binary.", "input": "To specify a numeric literal in binary:", "output": "`0b1011`"}
{"instruction": "`break` only breaks the current loop.", "input": "To break out of nested loops, you can:", "output": "Move does not support labeled breaks"}
{"instruction": "Move provides these fixed-width unsigned integer types.", "input": "Are all integers in Move fixed-width unsigned types?", "output": "Yes (u8, u64, u128)"}
{"instruction": "`let _ = x;` discards the value `x`.", "input": "To explicitly discard a value in Move:", "output": "Use `let _ = value;`"}
{"instruction": "Arithmetic overflows cause an abort.", "input": "Move supports which kind of integer overflow behavior?", "output": "Aborting on overflow"}
{"instruction": "Conversions must use the constructor-like functions.", "input": "To explicitly convert `u8` to `u64`:", "output": "`u64(x)`"}
{"instruction": "Strings are represented as `vector<u8>`.", "input": "Characters or strings in Move are represented as:", "output": "Move does not have native strings"}
{"instruction": "Multi-line comments use `/* */`.", "input": "To comment out multiple lines:", "output": "`/* ... */`"}
{"instruction": "Generics go after the struct name.", "input": "To declare a generic struct:", "output": "`struct S<T> { ... }`"}
{"instruction": "Similar to generic functions, use `<u64>`.", "input": "To instantiate a generic struct `S<T>` with `T = u64`:", "output": "`S<u64>{...}`"}
{"instruction": "`signer` represents the signing account of a transaction.", "input": "The `signer` type can only be obtained from:", "output": "Transaction context"}
{"instruction": "`Signer::address_of` returns the signer's address.", "input": "To read the address from a `signer s`:", "output": "`Signer::address_of(&s)`"}
{"instruction": "`loop` creates an infinite loop until `break`.", "input": "Looping indefinitely uses:", "output": "`loop { ... }`"}
{"instruction": "`abort <code>` stops execution with that code.", "input": "The `abort` statement expects:", "output": "An unsigned integer code"}
{"instruction": "Multiple abilities are comma-separated.", "input": "To define multiple abilities on a struct:", "output": "`struct S has key, store {}`"}
{"instruction": "Abilities like `key`, `store` define capabilities.", "input": "Abilities define:", "output": "What operations can be performed"}
{"instruction": "Must use a conversion function.", "input": "To convert `u64` to `u128`:", "output": "`u128(x)`"}
{"instruction": "All conversions are explicit for safety.", "input": "Move does not allow implicit type conversions to:", "output": "Prevent unintended data loss"}
{"instruction": "A script must define a single entry function, often named `main`.", "input": "A Move script can have:", "output": "One `main` function"}
{"instruction": "Scripts often start with `fun main(account: signer) { ... }`.", "input": "In Move, the `main` function of a script:", "output": "Has a fixed signature with a signer argument typically"}
{"instruction": "`let` introduces local variables.", "input": "Local variables in Move are declared with:", "output": "`let` or `let mut`"}
{"instruction": "Variables starting with `_` are allowed to be unused without warnings.", "input": "To ensure no warnings about unused variables:", "output": "Use `_x`"}
{"instruction": "Out-of-bound indexing aborts execution.", "input": "Vector indexing beyond length results in:", "output": "Abortion"}
{"instruction": "Copying is restricted to non-resource types that have the `copy` ability.", "input": "The `copy` operation is limited in Move because:", "output": "Resources cannot be copied"}
{"instruction": "`drop` indicates that values of this type can be dropped.", "input": "The `drop` ability means:", "output": "The value can be discarded"}
{"instruction": "`store` allows placement in global storage.", "input": "The `store` ability means:", "output": "The type can be stored in global storage"}
{"instruction": "`key` means the type can reside at an account address.", "input": "The `key` ability means:", "output": "It can serve as a global storage key"}
{"instruction": "Move has no type inference for parameters/returns.", "input": "Move functions always specify:", "output": "Parameter types and return types explicitly"}
{"instruction": "If a function returns nothing, it simply doesn\u2019t have a return statement or type.", "input": "To return nothing from a Move function, just:", "output": "Omit `return` and end the function"}
{"instruction": "Aborting is separate from returning normally.", "input": "Functions that abort with codes must have a return type:", "output": "They can still have normal return types"}
{"instruction": "`public(friend)` restricts visibility to friend modules.", "input": "You can use `public(friend)` to:", "output": "Make function visible only to modules declared as friends"}
{"instruction": "`friend <address>::Module;` declares friendship.", "input": "Friend modules are declared using:", "output": "`friend 0x1::M;`"}
{"instruction": "`friend` grants special access to listed modules.", "input": "The `friend` visibility is used to:", "output": "Allow internal API sharing"}
{"instruction": "The Move standard library code uses snake_case.", "input": "Move naming conventions:", "output": "snake_case"}
{"instruction": "`10u64` clarifies the type of the literal.", "input": "Numeric literal suffixes like `10u64`:", "output": "Are allowed"}
{"instruction": "`::` separates address, module, and function/struct.", "input": "The `::` operator in Move is used for:", "output": "Namespace qualification"}
{"instruction": "Dot notation is used for field access.", "input": "Struct fields are accessed by:", "output": "`s.field`"}
{"instruction": "No null references in Move.", "input": "References in Move:", "output": "Must always be valid and not null"}
{"instruction": "Resources can\u2019t be duplicated or simply reassigned without moving.", "input": "If a variable is bound to a resource value, can it be reassigned?", "output": "No, once you move a resource you must always track it; you cannot just reassign in a way that duplicates"}
{"instruction": "Comma-separated type parameters in angle brackets.", "input": "Generic functions with multiple type parameters look like:", "output": "{}`"}
{"instruction": "Type constraints use `:` to specify required abilities.", "input": "To ensure a function can only be called with types that implement `drop`, you can:", "output": "{}` in older syntax, but currently Move uses `fun foo<T: drop>(...)`. The abilities are specified with a colon, like `T: drop`."}
{"instruction": "`copy` allows duplication.", "input": "If `T` has the `copy` ability, you can:", "output": "Duplicate values of type T freely"}
{"instruction": "Destructure tuples with `let (x, y)`.", "input": "If a function returns `(u64, bool)`, how to extract both values?", "output": "= fun_call();`"}
{"instruction": "Abilities are type system constraints checked at compile time.", "input": "Abilities on generic parameters are enforced:", "output": "At compile time"}
{"instruction": "Move does not support inheritance.", "input": "Is there a `struct` inheritance mechanism in Move?", "output": "No"}
{"instruction": "`signer` represents the transaction sender\u2019s account.", "input": "A `signer` must be consumed or transformed how in a script\u2019s `main`?", "output": "Must be used to access account resources"}
{"instruction": "`signer` is a special type not allowed in vectors.", "input": "Can you have a vector of `signer`s?", "output": "No"}
{"instruction": "Conversions abort if out of range.", "input": "When converting between integer types (e.g. `u64` to `u8`), if the value doesn\u2019t fit:", "output": "It aborts"}
{"instruction": "No global mutable state except via resources stored under accounts.", "input": "Are global variables allowed in Move?", "output": "No"}
{"instruction": "`pop_back` returns the element removed.", "input": "The return value of `Vector::pop_back(&mut v)` is:", "output": "The popped element"}
{"instruction": "Struct fields can be borrowed or moved out if the struct is not needed.", "input": "Fields in a struct are accessed by value or by reference?", "output": "Can borrow or move fields depending on usage"}
{"instruction": "Borrow rules ensure safety.", "input": "Move promotes a strict discipline to prevent:", "output": "Data races and unexpected mutations"}
{"instruction": "Methods are just functions in the same module as the struct.", "input": "Can you implement methods directly on structs like in OOP?", "output": "No, only module-level functions exist"}
{"instruction": "Module names are identifiers that must follow naming rules.", "input": "Module names must start with:", "output": "A letter (following the identifier rules)"}
{"instruction": "Move does not do numeric inference.", "input": "Numeric type inference in Move:", "output": "No inference, must be explicit"}
{"instruction": "Lifetimes are enforced by static rules.", "input": "Borrowed references must:", "output": "Not outlive their referent"}
{"instruction": "The reference must remain valid.", "input": "If `fun foo(x: &u64)` is called with `foo(&y)`, `y` must:", "output": "Live at least as long as the call"}
{"instruction": "`copy` allows duplication.", "input": "The `copy` ability on a type T means:", "output": "Values of T can be copied"}
{"instruction": "`drop` means the value can be discarded.", "input": "The `drop` ability on a type T means:", "output": "Values of T can be dropped"}
{"instruction": "`key` is for global storage placement.", "input": "The `key` ability is often associated with:", "output": "Resource types in global storage"}
{"instruction": "`store` permits putting values in storage.", "input": "The `store` ability:", "output": "Allows global storage storage"}
{"instruction": "Without abilities, the type must be fully consumed.", "input": "A type with no abilities can be:", "output": "Only used locally and must be moved (no copy/drop/store)"}
{"instruction": "If no `has` clause, no abilities are given.", "input": "To define a struct with no abilities:", "output": "`struct S { ... }` without abilities"}
{"instruction": "Move aims for deterministic execution.", "input": "In Move, all code execution is:", "output": "Deterministic"}
{"instruction": "Move supports up to `u128`.", "input": "The maximum integer types in Move are:", "output": "`u128` is largest"}
{"instruction": "Bool is a basic copyable type.", "input": "Is `bool` a copyable type?", "output": "Yes, `bool` is copyable"}
{"instruction": "Primitives like integers are copyable.", "input": "Is `u64` copyable?", "output": "Yes, numeric types are copyable"}
{"instruction": "`vector` typically isn\u2019t copyable.", "input": "Is `vector<u8>` copyable by default?", "output": "No, vectors are not copyable unless their element type and vector itself have needed abilities (currently vectors do not have copy ability by default)"}
{"instruction": "Move does not have higher-order functions.", "input": "Can functions in Move be higher-order (take functions as arguments)?", "output": "No"}
{"instruction": "Move has no `no_abort` keyword; you must ensure no abort paths.", "input": "To ensure a function never aborts, you can:", "output": "Avoid aborting operations"}
{"instruction": "Types are always explicit.", "input": "Struct fields must be:", "output": "All have explicit types"}
{"instruction": "One mutable reference at a time per element.", "input": "After a `Vector::borrow_mut`, can you `borrow_mut` the same element again simultaneously?", "output": "No"}
{"instruction": "Move borrows concepts from Rust\u2019s memory safety.", "input": "Move\u2019s memory safety model:", "output": "Inspired by Rust\u2019s borrow model"}
{"instruction": "`/` operator for integer division.", "input": "To do integer division:", "output": "`x / y`"}
{"instruction": "`%` for modulo.", "input": "To do integer modulo:", "output": "`x % y`"}
{"instruction": "Division by zero causes abort.", "input": "Integer division by zero:", "output": "Aborts"}
{"instruction": "`assert` checks conditions and aborts if not met.", "input": "`assert(condition, code)` does what?", "output": "Aborts if false"}
{"instruction": "You can have many `assert`s.", "input": "Multiple `assert`s in a function:", "output": "Are allowed"}
{"instruction": "Standard Move uses `assert(condition, code)`.", "input": "`assert!(cond, code)` is:", "output": "Only `assert(cond, code)` is standard. `assert!(...)` might not be standard Move syntax."}
{"instruction": "Each field name must be distinct.", "input": "Field names in structs:", "output": "Must be unique"}
{"instruction": "Move restricts partial moves to prevent dangling references.", "input": "Can you partially move fields out of a struct?", "output": "Partial moves are restricted. You can move out certain fields if others have abilities that allow their safe discard or if you repackage them."}
{"instruction": "Vectors are homogeneous.", "input": "Vector elements must:", "output": "All of the same type T"}
{"instruction": "Out-of-range casts abort.", "input": "`u8(x)` casting where x > 255:", "output": "Aborts"}
{"instruction": "Scripts usually produce no return value.", "input": "A script\u2019s `main` can return:", "output": "Nothing typically"}
{"instruction": "Move currently lacks `continue`.", "input": "Is there a `continue` statement in Move loops?", "output": "Not currently supported"}
{"instruction": "Structs are defined at the module scope.", "input": "Struct definitions:", "output": "Cannot be nested inside functions; must be at module level"}
{"instruction": "Move IR is a lower-level textual representation of Move bytecode.", "input": "The Move IR (intermediate representation):", "output": "Is a lower-level IR for Move"}
{"instruction": "Comments are stripped out at compilation.", "input": "Comments in Move:", "output": "Not included in bytecode"}
{"instruction": "`0x1A` is hex for 26.", "input": "To define a constant with hex literal `const X: u64 = 0x1A;`, this sets X to:", "output": "Decimal 26"}
{"instruction": "`_param` is a convention to silence warnings.", "input": "Unused function parameters:", "output": "Cause warnings, `_` prefix can silence"}
{"instruction": "Float support is excluded for deterministic execution.", "input": "Move does not allow floating point numbers because:", "output": "Non-determinism"}
{"instruction": "No native strings, use `vector<u8>`.", "input": "To represent text, developers often use:", "output": "`vector<u8>`"}
{"instruction": "Abilities define what\u2019s allowed.", "input": "Ability checks ensure:", "output": "Types are used according to abilities"}
{"instruction": "Modules live at `address::ModuleName`.", "input": "Modules are identified by:", "output": "An address and a name"}
{"instruction": "Move modules are compiled individually.", "input": "Each module is compiled:", "output": "In isolation"}
{"instruction": "`public(entry)` is for entry functions callable as transaction scripts.", "input": "The `public(entry)` keyword:", "output": "Marks as an entry function"}
{"instruction": "This makes them callable like scripts.", "input": "Entry functions in modules can be called directly in transactions if:", "output": "`public(entry)`"}
{"instruction": "`const` are compile-time constants.", "input": "A `const` in Move must have a value:", "output": "Known at compile time"}
{"instruction": "Constants are immutable values.", "input": "You cannot mutate a `const` because:", "output": "It\u2019s compile-time constant"}
{"instruction": "Without `store`, cannot go into global storage.", "input": "To ensure a type can never appear in global storage:", "output": "Omit `store`"}
{"instruction": "Abort codes are unsigned integers.", "input": "`abort` codes are of type:", "output": "`u64`"}
{"instruction": "Move doesn\u2019t have a never type, aborting bypasses normal returns.", "input": "If a Move function never returns, only aborts, its return type:", "output": "Can still have a return type, but logically never reaches it"}
{"instruction": "Only single-level references.", "input": "Reference types in Move:", "output": "Just `&T` and `&mut T`"}
{"instruction": "Mutability is required to change the vector.", "input": "Passing a `&mut vector<T>` to `Vector::push_back` is necessary because:", "output": "It modifies in place"}
{"instruction": "Assertion failures abort.", "input": "`assert(x == y, code);` if `x != y` does what?", "output": "`abort code`"}
{"instruction": "Unused params typically warn.", "input": "Unused `signer` parameters:", "output": "Warn if not used (similarly to other parameters)"}
{"instruction": "Breaks when `cond` is true.", "input": "`loop { if cond { break; } }` behaves like:", "output": "Essentially a `while (!cond)` loop"}
{"instruction": "All fields must be initialized.", "input": "Struct field initialization:", "output": "Must set all fields"}
{"instruction": "A mutable reference is exclusive.", "input": "`&mut T` references are:", "output": "Exclusive references"}
{"instruction": "Mutable borrow is needed for both read and modify.", "input": "If you want to read and then modify a vector element, you must:", "output": "Borrow mutably once"}
{"instruction": "Out-of-range cast aborts.", "input": "Casting from `u128` to `u64` if value is large:", "output": "Aborts"}
{"instruction": "`Vector::singleton` returns a vector with one element.", "input": "`Vector::singleton(x: T): vector<T>`:", "output": "Creates a single-element vector"}
{"instruction": "All types explicit, no implicit conversions.", "input": "The Move compiler enforces:", "output": "Strict typing"}
{"instruction": "External calls must be fully qualified.", "input": "Module function calls require specifying:", "output": "Full qualification with address and module if external"}
{"instruction": "Move syntax and semantics borrow from Rust\u2019s principles.", "input": "Move\u2019s syntax is influenced by:", "output": "Rust"}
{"instruction": "Named addresses map to actual addresses at publishing time.", "input": "Named addresses in Move:", "output": "Symbolic named addresses"}
{"instruction": "Named addresses syntax.", "input": "A named address is declared:", "output": "`address MyAddr = 0x1;`"}
{"instruction": "They enable code to be reused with different addresses.", "input": "Named addresses help with:", "output": "Reusability/configurability"}
{"instruction": "`use` shortens the path.", "input": "If you write `use 0x1::Vector;` at top of a module:", "output": "You can refer to it as `Vector`"}
{"instruction": "`use` just shortens references.", "input": "`use` imports:", "output": "Purely syntactic sugar"}
{"instruction": "`signer` must come from a signed transaction.", "input": "When a function needs a `signer` parameter:", "output": "The caller must supply one"}
{"instruction": "Comma separated abilities.", "input": "Abilities can be combined, for example:", "output": "`struct S has copy, drop {}`"}
{"instruction": "`public` comes before `fun`.", "input": "The `public fun` syntax is actually:", "output": "{ ... }`"}
{"instruction": "Restricts visibility to friends.", "input": "`public(friend) fun` means:", "output": "Accessible by friend modules only"}
{"instruction": "`public(entry)` marks entry functions.", "input": "`public(entry) fun main(...)` means:", "output": "Entry function"}
{"instruction": "Entry functions often require signers.", "input": "An entry function must have:", "output": "Typically includes `signer` arguments"}
{"instruction": "Move VM has a bytecode verifier.", "input": "The `bytecode` produced by Move:", "output": "Verified by the Move VM"}
{"instruction": "Identifiers start with letter/underscore.", "input": "Identifier naming rules in Move:", "output": "Similar to Rust/C rules"}
{"instruction": "Similar to C/Rust.", "input": "Semicolons in Move:", "output": "Used to terminate statements"}
{"instruction": "Conditions in `if` are enclosed in parentheses.", "input": "Parentheses in conditions (e.g. `if (x == y)`) are:", "output": "Required"}
{"instruction": "Always require `{}`.", "input": "Curly braces in `if` statements:", "output": "Required"}
{"instruction": "Move doesn\u2019t do implicit return like Rust.", "input": "Returns without `return` keyword:", "output": "Must use `return` keyword to return early"}
{"instruction": "Optimizations are possible.", "input": "Dead code elimination:", "output": "The compiler or VM can optimize dead code"}
{"instruction": "These built-ins manage global storage.", "input": "Global storage access is done via:", "output": "`move_to` and `move_from`"}
{"instruction": "`move_from` moves resource out of global storage.", "input": "`move_from<T>(addr)` does:", "output": "Removes resource from storage"}
{"instruction": "`move_to` stores resource at an address.", "input": "`move_to<T>(addr, val)` does:", "output": "Places resource in global storage"}
{"instruction": "`exists` checks if resource is present.", "input": "`exists<T>(addr)` returns:", "output": "bool"}
{"instruction": "`borrow_global` aborts if the resource doesn\u2019t exist.\n\n---\n\n### 201\u2013400: Resources", "input": "`borrow_global<T>(addr)` and `borrow_global_mut<T>(addr)` return:", "output": "A reference or abort if not present"}
{"instruction": "Resources are linear types that cannot be duplicated or dropped arbitrarily.", "input": "A resource in Move:", "output": "Cannot be copied freely"}
{"instruction": "Ensures resource integrity.", "input": "Resources must be moved instead of copied to prevent:", "output": "Double spending or duplication"}
{"instruction": "Resources typically reside under accounts.", "input": "Resources are often stored:", "output": "In global storage under an address"}
{"instruction": "`key` means it can live at an address.", "input": "The `key` ability in a struct:", "output": "Publishable resource"}
{"instruction": "`move_to` publishes a resource.\n\nBelow are questions 206\u2013400 continuing the \"Resources\" category. Each question includes difficulty (easy, medium, hard), category (Resources), a question, four options (a\u2013d), the correct answer, and a brief explanation. We ended at question 205 previously, so we start now at 206.\n\n**Note:**  \n- Questions 201\u2013250: Easy  \n- Questions 251\u2013300: Medium  \n- Questions 301\u2013400: Hard\n\nWe have already done up to question 205 (Easy). We will continue with Easy for 206\u2013250, then Medium for 251\u2013300, and Hard for 301\u2013400, all under the \"Resources\" category.\n\n---\n\n### Resources (201\u2013250: Easy continued)", "input": "The `move_to<T>` function:", "output": "Places resource into storage"}
{"instruction": "`move_from` removes and returns the resource from `addr`.", "input": "To remove a resource `T` from global storage at address `addr`, you use:", "output": "`move_from<T>(addr)`"}
{"instruction": "`borrow_global` aborts if the resource does not exist.", "input": "If `exists<T>(addr)` returns `false`, calling `borrow_global<T>(addr)` will:", "output": "Abort with an error"}
{"instruction": "The `key` ability lets a resource be published at an address.", "input": "A resource type must have the `key` ability to be:", "output": "Stored in global storage under an address"}
{"instruction": "`move_to` moves a resource of type T into global storage.", "input": "When you `move_to<T>(addr, t)`, `t` must be:", "output": "A resource value of type T"}
{"instruction": "Global storage acts like a map from type to a single resource instance.", "input": "Can you have two resources of the same type T under the same address?", "output": "No, only one instance per address per type"}
{"instruction": "Storing a resource that already exists under the same address is not allowed.", "input": "Attempting to `move_to<T>(addr, t)` when a `T` already exists at `addr` will:", "output": "Abort"}
{"instruction": "`borrow_global` gives an immutable reference.", "input": "`borrow_global<T>(addr)` returns:", "output": "An immutable reference `&T`"}
{"instruction": "`borrow_global_mut` allows mutation of the stored resource.", "input": "`borrow_global_mut<T>(addr)` returns:", "output": "`&mut T`"}
{"instruction": "`exists` returns true if the resource is present.", "input": "To check if a resource of type T exists at `addr`, use:", "output": "`exists<T>(addr)`"}
{"instruction": "`move_from` removes the resource from global storage and returns it.", "input": "If `exists<T>(addr)` is true, then `move_from<T>(addr)` will:", "output": "Return the resource and remove it"}
{"instruction": "Resources model valuable assets with strict move semantics.", "input": "Resources can be thought of as:", "output": "Digital assets that cannot be arbitrarily duplicated"}
{"instruction": "Resources prevent unintended duplication or loss of assets.", "input": "One reason Move uses resources is to represent:", "output": "On-chain assets like coins"}
{"instruction": "Without `drop`, the resource must be accounted for at the end of scope.", "input": "If a resource has no `drop` ability, you must:", "output": "You must use or store it"}
{"instruction": "`store` is required to put the resource in global storage.", "input": "The `store` ability allows a resource to:", "output": "Be stored in global storage"}
{"instruction": "`key` lets the resource be published under an account.", "input": "The `key` ability:", "output": "Allows it to be a top-level resource at an address"}
{"instruction": "Without `key`, it can\u2019t be globally stored.", "input": "If a resource type does not have `key`, it cannot be:", "output": "Published to global storage"}
{"instruction": "Mutable references allow in-place mutation.", "input": "To mutate a global resource, you must first:", "output": "Borrow it mutably"}
{"instruction": "Transactions are atomic; abort rolls back to previous state.", "input": "If you `abort` in the middle of mutating a resource:", "output": "Changes are rolled back"}
{"instruction": "No unauthorized copies or drops.", "input": "Resources ensure linear usage, meaning:", "output": "Must track usage linearly"}
{"instruction": "Resources are moved, not copied, into functions.", "input": "A resource can be passed as a function parameter if:", "output": "It is moved"}
{"instruction": "`move_from` removes it from storage.", "input": "After `move_from<T>(addr)`, the resource T:", "output": "No longer exists at `addr`"}
{"instruction": "You must not leave a resource \"floating\"; it must be used or stored.", "input": "If you never `move_to` a resource back to an address after taking it with `move_from`, the resource:", "output": "Must be accounted for before end of scope"}
{"instruction": "Without `drop`, you can\u2019t discard the resource at the end of scope.", "input": "A resource without `drop` cannot just be thrown away, it must be:", "output": "Moved to storage or used"}
{"instruction": "Ensures financial asset safety.", "input": "Resources are a key concept in Move mainly because:", "output": "They prevent asset duplication"}
{"instruction": "No resource exists to move from.", "input": "If `exists<T>(addr)` is false, calling `move_from<T>(addr)` will:", "output": "Abort"}
{"instruction": "Each address can hold one instance of a resource type.", "input": "Global storage is conceptually like:", "output": "A mapping from `(address,type)` to `resource`"}
{"instruction": "`key` + `store` enables storage in global state.", "input": "The `key` ability is often combined with `store` to:", "output": "Allow publishing"}
{"instruction": "`drop` lets you not use it by the end of the function.", "input": "If a resource has the `drop` ability, it means:", "output": "It can be discarded"}
{"instruction": "Immutable borrow to read.", "input": "To read but not change a global resource, use:", "output": "`borrow_global<T>(addr)`"}
{"instruction": "Mutable reference needed to mutate.", "input": "To modify a global resource in-place:", "output": "`borrow_global_mut<T>(addr)`"}
{"instruction": "`move_to` restores it to global storage.", "input": "If you `move_from<T>(addr)`, to put it back you must eventually:", "output": "`move_to<T>(addr, resource)`"}
{"instruction": "You can hold resources locally, but must use them properly.", "input": "If a resource is not stored globally, it can be stored:", "output": "Locally in a variable (must be accounted for)"}
{"instruction": "It can\u2019t vanish unused.", "input": "If a resource has no `drop`, you cannot just let it go out of scope without:", "output": "Must move or return it"}
{"instruction": "Scripts can move resources in and out, but still must follow rules.", "input": "Are resources allowed in scripts?", "output": "Yes, respecting linearity"}
{"instruction": "Ensures uniqueness.", "input": "To ensure a resource is unique and not duplicated, Move\u2019s type system:", "output": "Disallows copying resources"}
{"instruction": "Resources usually lack `copy` to maintain scarcity.", "input": "A resource type that also has `copy` would:", "output": "Break the semantics, generally disallowed"}
{"instruction": "Must have `key` to publish.", "input": "If you `move_to<T>(addr, t)`, and `t` does not have `key` ability:", "output": "Abort"}
{"instruction": "On-chain storage ties resources to an address.", "input": "Storing a resource under an address associates it:", "output": "With the account\u2019s storage"}
{"instruction": "It queries the global state.", "input": "You can think of `exists<T>(addr)` as:", "output": "Checks if `(addr,T)` pair is in storage"}
{"instruction": "Linear type discipline.", "input": "Resources must be handled carefully at the end of a function because:", "output": "Must use or store them"}
{"instruction": "One mutable reference at a time ensures safety.", "input": "Mutating a global resource requires a mutable borrow, ensuring:", "output": "Safe concurrent access"}
{"instruction": "`drop` lets you ignore it at the end.", "input": "If a resource has `drop`, you can end the function without using it by:", "output": "Dropping is allowed"}
{"instruction": "Move semantics to transfer ownership.", "input": "To transfer a resource from one address to another, you could:", "output": "Move it out then move it into another address"}
{"instruction": "Functions can return resources by moving them.", "input": "Resources can also be passed as function return values by:", "output": "Moving them out as return values"}
{"instruction": "Ensures correctness and safety of digital assets.\n\n### Resources (251\u2013300: Medium)", "input": "A key property of resources in Move is that they:", "output": "Cannot be duplicated or discarded implicitly"}
{"instruction": "After re-storing it, the global state updates to `new_t`.", "input": "If you `move_from<T>(addr)` and modify the returned resource locally, when you `move_to<T>(addr, new_t)`, the global state now:", "output": "Updated resource is stored"}
{"instruction": "Borrowing non-existent resource aborts.", "input": "Consider a resource `Coin` with `key, store`. If `exists<Coin>(addr)` is false and you call `borrow_global<Coin>(addr)`, what happens?", "output": "Abort occurs"}
{"instruction": "Must explicitly check before borrowing or moving.", "input": "To conditionally access a resource if it exists, one common pattern is:", "output": "Check `exists<T>(addr)` first"}
{"instruction": "Without `drop` or `copy`, it must be fully accounted for.", "input": "A resource that implements neither `drop` nor `copy`:", "output": "Fully linear usage required"}
{"instruction": "Move out to local scope, modify, move back.", "input": "If you want to temporarily remove a resource from global storage to modify it heavily and then put it back:", "output": "`move_from`, then `move_to`"}
{"instruction": "Mutable reference lets you change the resource in storage.", "input": "If you have `&mut T` from `borrow_global_mut<T>(addr)`, you can:", "output": "Modify in-place"}
{"instruction": "Resource semantics ensure correctness.", "input": "Handling resources in Move primarily ensures:", "output": "Strong invariants for assets"}
{"instruction": "`store` allows placement in storage.", "input": "If a resource type T also has the `store` ability:", "output": "It can appear in global storage structures"}
{"instruction": "`drop` is about discard; `key` and `store` are about publication.", "input": "A resource with `drop` ability can still be published if:", "output": "Needs `key` and `store` for global publication"}
{"instruction": "The difference is mutability of the returned reference.", "input": "`borrow_global` and `borrow_global_mut` differ mainly in:", "output": "Immutable vs mutable references"}
{"instruction": "Exclusive mutable references prevent other concurrent borrows.", "input": "If you `borrow_global_mut<T>(addr)`, you must ensure:", "output": "No simultaneous conflicting borrows"}
{"instruction": "Multiple immutable references are safe.", "input": "To safely read a resource multiple times in a function, you can:", "output": "Multiple immutable borrows are allowed if no mutation occurs"}
{"instruction": "Logic ensures resource presence is maintained.", "input": "If a resource is crucial and must always be present at an address, you might:", "output": "Respect invariants to always restore it"}
{"instruction": "Resource no longer in storage, you must account for it.", "input": "If you `move_from<T>(addr)` in a transaction and never `move_to` it back:", "output": "Must handle it locally or return it"}
{"instruction": "It\u2019s a pure linear type, must be moved around carefully.", "input": "A resource without `drop` or `store` can still be:", "output": "Passed around linearly"}
{"instruction": "Dropping a resource is like destroying it.", "input": "To implement a \u201cburn\u201d mechanism for a coin resource (removing it from circulation):", "output": "With `drop`, you can let it vanish, simulating burning"}
{"instruction": "Without `drop`, must find a legal way to handle its end-of-life.", "input": "If a resource does not have `drop`, you cannot burn it unless:", "output": "Must transform it or move it to a form that can be dropped"}
{"instruction": "Resource movement must preserve invariants.", "input": "Ensuring a resource\u2019s invariants often involves:", "output": "Control moves in and out of storage"}
{"instruction": "On-chain resources persist beyond a single transaction.", "input": "When a resource is published (moved to global storage), its memory:", "output": "Persists in global storage between transactions"}
{"instruction": "Globals are stateful and persistent.", "input": "One key difference between local variables and global resources:", "output": "Globals persist on-chain, locals are ephemeral within a transaction"}
{"instruction": "`key` is needed for on-chain storage as a top-level item.", "input": "A resource type might require a `key` ability if:", "output": "Required for publishing under an address"}
{"instruction": "Immutable borrow to read without extraction.", "input": "To temporarily read a resource without removing it from storage, you should:", "output": "`borrow_global<T>(addr)`"}
{"instruction": "Mutable borrow ensures exclusivity.", "input": "If you need to mutate a global resource but also ensure no one else reads it simultaneously:", "output": "`borrow_global_mut<T>(addr)`"}
{"instruction": "They add/remove resources from the on-chain map.", "input": "In Move, `move_to` and `move_from` can be thought of as:", "output": "They modify the global resource state"}
{"instruction": "Verifier and runtime checks prevent misuse.", "input": "The Move VM checks resource operations at runtime to ensure:", "output": "Safety at runtime"}
{"instruction": "The resource is moved out successfully.", "input": "If you try to `move_from<T>(addr)` and `exists<T>(addr)` is true, the call:", "output": "Succeeds"}
{"instruction": "You can borrow mutably and choose not to mutate.", "input": "If you `borrow_global_mut<T>(addr)` and then do not modify the resource, is that allowed?", "output": "Allowed"}
{"instruction": "Partial moves must adhere to linearity rules.", "input": "Partial moves of a resource\u2019s fields:", "output": "Restricted"}
{"instruction": "Move semantics are not size-dependent.", "input": "If a resource is large, does that affect how `move_from` works?", "output": "Size doesn\u2019t conceptually change the semantics"}
{"instruction": "The resource remains unique.", "input": "Can a resource be cloned by first `move_from` and then `move_to` without changing it?", "output": "No cloning, it\u2019s the same resource moved out and back"}
{"instruction": "No two simultaneous mutable borrows allowed.", "input": "If you `exists<T>(addr)` and it returns true, but `borrow_global_mut<T>(addr)` is called twice concurrently:", "output": "The second call aborts"}
{"instruction": "Ideal for representing token-like assets.", "input": "Resources provide a mechanism to implement what kind of patterns safely?", "output": "Ownership patterns for assets"}
{"instruction": "Immutably borrowing allows inspection without moving it.", "input": "If you need a function to check a resource\u2019s field without taking ownership:", "output": "Borrow immutably and read the field"}
{"instruction": "Modules must ensure no conflicting operations occur concurrently.", "input": "If two modules manage the same resource type T at the same address:", "output": "Coordination is needed"}
{"instruction": "Must have `key` to be published.", "input": "`move_to` and `move_from` operations:", "output": "Only for `key` resources"}
{"instruction": "Resource no longer exists in storage after `move_from`.", "input": "The type system ensures that once a resource is moved out of global storage:", "output": "Cannot borrow it from storage after it\u2019s removed"}
{"instruction": "Core design goal.", "input": "The design of resources in Move primarily aims to:", "output": "Model scarcity and uniqueness"}
{"instruction": "Proper testing ensures correctness.", "input": "When testing code that manages resources, you must:", "output": "Consider all resource operations carefully"}
{"instruction": "Return passing ownership upward.", "input": "If a resource is returned from a function:", "output": "Moved to the caller"}
{"instruction": "Verifier enforces resource rules.", "input": "The Move VM\u2019s verifier checks resource usage to:", "output": "Prevent invalid states"}
{"instruction": "Mutable borrow excludes other borrows.", "input": "If `borrow_global_mut<T>(addr)` is in use, trying to `borrow_global<T>(addr)` at the same time:", "output": "Aborts due to conflict"}
{"instruction": "Designed for on-chain asset representation.", "input": "Resources can help implement:", "output": "Token economies with invariants"}
{"instruction": "Only one instance per `(addr, T)`.", "input": "Attempting `move_to<T>(addr, t)` twice in the same transaction without a `move_from` in between:", "output": "Aborts, resource already there"}
{"instruction": "Mutable ref allows in-place update.", "input": "If you have a mutable reference to a resource, you can:", "output": "Change fields before releasing reference"}
{"instruction": "`key` is only required for global storage.", "input": "If a resource type T is never published to global storage, do you still need `key`?", "output": "No need for `key` if not storing globally"}
{"instruction": "`store` is required for global storage.", "input": "Without `store`, you:", "output": "Cannot store it globally"}
{"instruction": "Violations cause runtime aborts.", "input": "Resources enforce linearity at runtime by:", "output": "Aborting on violations"}
{"instruction": "All resources must be accounted for at the end.", "input": "If you `move_from<T>(addr)` a resource and forget to `move_to` it back, but you end the transaction:", "output": "Must handle it before end of transaction execution"}
{"instruction": "Encourages careful resource management.", "input": "By design, resources and their operations encourage developers to:", "output": "Explicit handling of asset data flows"}
{"instruction": "They move resources in/out of global storage like a bank.\n\n---\n\n### Resources (301\u2013400: Hard)", "input": "You can think of `move_from` and `move_to` as analogous to:", "output": "Withdrawal/deposit metaphor"}
{"instruction": "Linear resource must be used, stored, or returned.", "input": "Consider a resource `R` without `drop` or `copy` and with `key` and `store`. You `move_from<R>(addr)`, modify it, and end the function without `move_to<R>(addr)` or returning it. The compiler:", "output": "Compiler error: resource must not be left unused"}
{"instruction": "`drop` allows this behavior.", "input": "If a resource has the `drop` ability, does it mean you can just `let _ = resource;` to discard it?", "output": "Yes, you can discard it with `drop`"}
{"instruction": "Resource upgrades often done by taking it out and republishing in new form.", "input": "To implement a resource upgrade (changing its structure and re-storing it):", "output": "Move out, transform, move back"}
{"instruction": "You must not hold two mut borrows at once, but can release one then borrow again.", "input": "Can you borrow the same resource as mutable more than once if you return the first mutable reference before taking another?", "output": "Sequential mutable borrows are fine"}
{"instruction": "Both `key` and `store` needed for storing resources globally.", "input": "If you try to `move_to<T>(addr, t)` where `t` lacks `store` ability, even if `t` has `key`:", "output": "Abort, need `store` to place in storage"}
{"instruction": "`key` without `store` is effectively pointless for global storage.", "input": "If a resource has `key` but not `store`, what is its meaning?", "output": "It can\u2019t actually be stored globally, making `key` moot"}
{"instruction": "`store` allows it to appear inside another `key` resource.", "input": "If a resource has `store` but not `key`, you can:", "output": "It can be stored inside other published resources"}
{"instruction": "`store` allows nesting inside other resources.", "input": "To create a hierarchical resource structure (resource inside resource), the inner resource must have:", "output": "`store` ability"}
{"instruction": "Cannot remove a resource from storage while it\u2019s borrowed.", "input": "If you `borrow_global<T>(addr)` and keep that reference, calling `move_from<T>(addr)` meanwhile will:", "output": "Abort due to invalidating an active borrow"}
{"instruction": "Borrow rules are enforced statically by the verifier.", "input": "The verifier ensures no two mutable borrows or a mutable and an immutable borrow overlap on the same resource:", "output": "At bytecode verification time"}
{"instruction": "Partial moves must maintain linearity.", "input": "If you attempt to partially move a field from a resource struct without either dropping the remaining fields or reassembling them:", "output": "Compiler error"}
{"instruction": "All parts must be handled to respect linearity.", "input": "To reassemble a partially moved resource, you must:", "output": "Rebuild the resource with all fields before ending scope"}
{"instruction": "Nested resources come along with their container.", "input": "If a resource type T is stored inside another resource U, and U is published at addr:", "output": "Extracting U also extracts all nested resources inside it"}
{"instruction": "References ensure exclusive or shared access as per rules.", "input": "The Move memory model ensures that once a resource is borrowed, the underlying data:", "output": "Locked by the borrow"}
{"instruction": "Structural changes require taking it out and replacing it.", "input": "To safely upgrade a resource\u2019s schema (e.g., add a field), a common pattern is:", "output": "Move out, rebuild in new form, move in"}
{"instruction": "Resource discipline encourages correct handling in code.", "input": "If a resource\u2019s invariants must hold globally, any `move_from` and `move_to` operations must:", "output": "Must enforce invariants"}
{"instruction": "Resources are data governed by linearity rules.", "input": "A resource can implement complex logic, but at the end of the day, the Move VM treats it as:", "output": "A structured value with linear semantics"}
{"instruction": "`key` + `store` = flexible global storage placement.", "input": "The combination of `key` and `store` abilities indicates a resource can be:", "output": "Stored globally in various ways"}
{"instruction": "No `drop` means must not be abandoned.", "input": "Without `drop`, a resource must be:", "output": "Must be used or stored"}
{"instruction": "To persist it on-chain, must `move_to` before ending.", "input": "If a resource is used as input to a function, it is moved into that function. If the function wants to maintain it globally after modification:", "output": "`move_to` it back"}
{"instruction": "Modules must coordinate to prevent conflicting operations.", "input": "In a scenario where multiple modules need to coordinate access to the same resource type at an address:", "output": "A careful design is required"}
{"instruction": "It\u2019s allowed but pointless.", "input": "If a resource T is never going to be published globally, but you give it `key`, is there a penalty?", "output": "No functional penalty, just unnecessary"}
{"instruction": "Clarity helps developers.", "input": "To avoid confusion, resource types intended for global storage typically:", "output": "Document that they have `key` and `store`"}
{"instruction": "No resource found means abort.", "input": "Attempting `move_from<T>(addr)` on a type T that does not exist at `addr` leads to:", "output": "Abort"}
{"instruction": "Ensures consistent state across transactions.", "input": "Managing a resource of type T across multiple transactions:", "output": "Always restore invariants before transaction completion"}
{"instruction": "Semantics do not depend on size/complexity.", "input": "If a resource is large and complex, does Move\u2019s resource semantics change?", "output": "Same rules apply"}
{"instruction": "Nested resource manipulation follows linearity rules.", "input": "If a resource is stored inside another resource that\u2019s published, to remove the inner resource you must:", "output": "Remove outer, modify structure, republish"}
{"instruction": "Controlled aliasing ensures safety.", "input": "Resources strongly limit aliasing because:", "output": "Single mutable reference eliminates multiple aliasing"}
{"instruction": "Transformation often requires removal and re-publication.", "input": "To convert a resource into another form without `drop`:", "output": "Move out, transform, move in a new form"}
{"instruction": "Module boundaries protect resource fields.", "input": "If a resource\u2019s value must not be visible to unauthorized modules, you can:", "output": "Module encapsulation"}
{"instruction": "Encapsulation in the defining module.", "input": "To ensure only one module can manipulate a given resource type T:", "output": "Control access through module functions"}
{"instruction": "Immutable borrow still prevents removal.", "input": "If a resource is borrowed immutably and you call `move_from` on it:", "output": "Abort"}
{"instruction": "Lifetime is explicitly controlled.", "input": "In Move, a resource\u2019s lifetime:", "output": "Ends when explicitly moved or dropped"}
{"instruction": "Typically done in modules or through entry functions.", "input": "Global storage operations like `move_to` and `move_from`:", "output": "Generally require module logic or entry functions; scripts can call these functions"}
{"instruction": "No automatic migrations, must handle explicitly.", "input": "If a resource type T changes over time (new fields in new module versions), to migrate old stored T to new T:", "output": "Manual migration by `move_from`/`move_to`"}
{"instruction": "Mut borrow excludes any other borrow.", "input": "If `borrow_global_mut<T>(addr)` is obtained, calling `borrow_global<T>(addr)` inside the same scope:", "output": "Aborts"}
{"instruction": "Must manually code conditional logic.", "input": "To emulate conditional resource existence handling, you might do:", "output": "Check `exists` before `move_from`"}
{"instruction": "Nested resources must be storable.", "input": "Resources can contain vectors of other resources if:", "output": "`store` needed for nested storage"}
{"instruction": "A mutable reference doesn\u2019t let you remove it from storage.", "input": "If you have a mutable reference `&mut T`, you can:", "output": "Mutate fields in place only"}
{"instruction": "Module design is crucial for correct resource management.", "input": "When designing modules handling multiple resource types:", "output": "Carefully design invariant maintenance"}
{"instruction": "Scope-based lifetime rules.", "input": "To release a mutable borrow, simply:", "output": "Out of scope ends the borrow"}
{"instruction": "Access controlled by module boundaries.", "input": "If a resource is defined in one module and managed by another:", "output": "Must have `public` functions or `friend` access"}
{"instruction": "Without `store`, it\u2019s confined to local usage.", "input": "If a resource does not have `store`, you can still:", "output": "Use it locally only"}
{"instruction": "This is a form of linear type discipline.", "input": "The Move type system preventing resource copying is analogous to:", "output": "Linear logic"}
{"instruction": "`drop` allows discarding.", "input": "If you want a resource to be easily discardable, give it:", "output": "`drop`"}
{"instruction": "Needed for global storage usage.", "input": "If you want a resource to be usable as a global ledger entry:", "output": "`key` and `store` for global ledger usage"}
{"instruction": "Resource was already moved out.", "input": "Attempting to `move_from<T>(addr)` twice without re-storing T:", "output": "Aborts (no T found second time)"}
{"instruction": "Borrow rules prevent data races.", "input": "Ensuring no data races on on-chain resources is achieved by:", "output": "Exclusive mutable borrow rules"}
{"instruction": "Mutable borrow allows direct in-place update.", "input": "Changing a field in a borrowed mutable resource does not require:", "output": "No need to remove and re-add the resource, just mutate in place"}
{"instruction": "Navigate references inside the top-level resource.", "input": "If a resource is deeply nested inside others, to access it you might:", "output": "Mutably borrow outer and traverse fields"}
{"instruction": "Module encapsulation enforces privacy.", "input": "If a resource must never be visible to users outside the defining module:", "output": "Keep it private to the module\u2019s API"}
{"instruction": "Move\u2019s linear typing prevents leaving resources behind.", "input": "If a resource is taken out of storage (`move_from`), but you forget to put it back or return it, the function:", "output": "Compile-time error (resource leakage)"}
{"instruction": "Direct analogy to linear logic.", "input": "The Move model makes resources resemble:", "output": "Affine/linear typed values"}
{"instruction": "Resources are for non-copyable assets.", "input": "If you want to implement a resource that can be freely copied (like a normal integer):", "output": "Normal types can be copyable, resources typically are not meant to be copied"}
{"instruction": "`drop` allows discard, no `key/store` means no global storage.", "input": "A resource with `drop` but no `key` or `store`:", "output": "Freely discarded locally, no global storage"}
{"instruction": "Mut borrow locks the resource.", "input": "Once you `borrow_global_mut<T>(addr)`, can you `move_from<T>(addr)` in the same scope before the mutable borrow ends?", "output": "No, active mut borrow prevents removal"}
{"instruction": "Pattern depends on existence check.", "input": "To implement a safe \u201cupdate or insert\u201d pattern for a global resource T:", "output": "Condition on `exists` and then either mutate or insert"}
{"instruction": "Borrowing allows partial access.", "input": "If a resource is large and complex, and you only need to read a small part of it:", "output": "Borrow immutably and read the portion you need"}
{"instruction": "Extra care in handling.", "input": "Attempting complex manipulations often involves temporarily pulling a resource out of storage with `move_from`. A downside is:", "output": "Must restore or use, adding complexity"}
{"instruction": "Maintain invariants and linear usage.", "input": "When refactoring code that handles resources, you must keep in mind:", "output": "Respect linearity in refactoring"}
{"instruction": "Resource rules map well to digital asset integrity.", "input": "A resource-based approach to token management in Move ensures:", "output": "Prevents double-spend"}
{"instruction": "Passing moves ownership.", "input": "If you need to hand off a resource to another function:", "output": "Move it into the function parameter"}
{"instruction": "Return passes ownership to caller.", "input": "To return a resource from a function, you must:", "output": "Returning moves it to the caller"}
{"instruction": "Conditional logic often uses `borrow_global` before `move_from`.", "input": "If you want to conditionally remove a resource from storage only if it meets some criteria:", "output": "Borrow and check, then move if conditions met"}
{"instruction": "Prevents resource leakage.", "input": "The verifier prevents a situation where a resource is:", "output": "Ensures linear usage"}
{"instruction": "Each type is a separate slot.", "input": "If you have multiple resources of different types under the same address:", "output": "They can all exist, each type at most one instance"}
{"instruction": "Perfect for modeling state changes.", "input": "When using resources to represent state machines:", "output": "Movement and mutation represent state transitions"}
{"instruction": "Mutable borrow updates resource directly.", "input": "If you use `borrow_global_mut<T>(addr)` to increment a counter field in T:", "output": "Mutation in-place updates global state"}
{"instruction": "Without `drop`, discard is not allowed.", "input": "If a resource does not have `drop`, trying to just `let _ = resource;` at the end:", "output": "Error, must handle resource properly"}
{"instruction": "Primary design goal.", "input": "The linear type system of resources aligns with Move\u2019s goal to:", "output": "Safe handling of digital assets"}
{"instruction": "Module-level encapsulation.", "input": "In a complex module, if a resource is only meant to be manipulated by certain functions:", "output": "Restrict access to ensure integrity"}
{"instruction": "Active mut borrow prevents `move_from`.", "input": "If a resource is borrowed mutably, can you call functions that `move_from` the same resource type at the same address in nested calls?", "output": "No, conflict occurs"}
{"instruction": "Partial moves are tricky and must reassemble the resource.", "input": "If you need to temporarily separate fields of a resource, you must:", "output": "Full resource handling required"}
{"instruction": "`exists` is read-only.", "input": "`exists<T>(addr)` is a pure function that:", "output": "Pure check, no modifications"}
{"instruction": "Formal verification can enforce resource invariants.", "input": "Integrating resources with formal verification:", "output": "Specs can help prove resource correctness"}
{"instruction": "Simplifies reasoning about invariants.", "input": "If multiple modules handle the same resource type, a good practice is:", "output": "Centralize control to maintain invariants"}
{"instruction": "Must be handled linearly in local scope.", "input": "A resource without `drop` or `key` or `store`:", "output": "Pure linear local type"}
{"instruction": "Immutable reference prevents mutation.", "input": "`borrow_global<T>(addr)` returning `&T` ensures:", "output": "Immutability during that borrow"}
{"instruction": "Designed for blockchain use cases.", "input": "The Move language\u2019s resource model is particularly suited for:", "output": "On-chain assets and contracts"}
{"instruction": "You must handle it linearly.", "input": "If you receive a resource from a caller, and you must ensure it leaves your function in a consistent state:", "output": "Must ensure consistent handling"}
{"instruction": "Ensures stability.", "input": "If a resource must always remain at a particular address:", "output": "Keep it in place, mutate via borrowing"}
{"instruction": "Transactions are atomic, so if abort, revert happens.", "input": "To atomically swap two resources at two different addresses is:", "output": "Must carefully orchestrate moves"}
{"instruction": "Pre-checking existence prevents runtime aborts.", "input": "Checking `exists<T>(addr)` before `borrow_global<T>(addr)` is a good pattern to:", "output": "Avoid abort if absent"}
{"instruction": "Reuse immutable reference.", "input": "If you intend to read a resource multiple times in a function without changing it:", "output": "One immutable borrow reused for multiple reads"}
{"instruction": "Encapsulation offers a safe API.", "input": "If a resource type T is managed only internally by a module, external callers:", "output": "The module provides a safe interface"}
{"instruction": "Efficient in-place updates.", "input": "A resource-based ledger might store user balances as resources at their addresses. To adjust a user\u2019s balance:", "output": "Mutable borrow and update"}
{"instruction": "Cannot overwrite an existing resource.", "input": "If you try to `move_to<T>(addr, t)` and `exists<T>(addr)` is true:", "output": "Abort"}
{"instruction": "`move_from`, `move_to`, `borrow` = state transitions.", "input": "Designing resource logic often resembles designing:", "output": "State machines"}
{"instruction": "Less overhead than removing and re-storing.", "input": "If a resource is very frequently updated, using `borrow_global_mut` might be better than `move_from/move_to` because:", "output": "Directly mutate in place is simpler"}
{"instruction": "Must enforce invariants in code or specs.", "input": "If you fail to ensure resource invariants (like a coin not going negative), it could lead to:", "output": "Logical errors and vulnerabilities"}
{"instruction": "Verification ensures correct resource handling.", "input": "In a scenario of complex nested resources, formal verification can help by:", "output": "Prove correctness properties"}
{"instruction": "Manual migrations are common.", "input": "To \u201cupgrade\u201d a resource schema across module versions, developers might write:", "output": "Migration scripts handle version changes"}
{"instruction": "Keep it encapsulated.", "input": "If a resource\u2019s fields must remain secret, do not:", "output": "Don\u2019t expose fields or public moves"}
{"instruction": "Resources can model capabilities securely.", "input": "A resource can represent a capability (like permission to do something). By controlling `move_from`/`move_to`, you:", "output": "Control capability distribution"}
{"instruction": "Must handle returned resource properly.", "input": "If a resource is returned from a function and the caller ignores it without `drop`:", "output": "Compile-time error"}
{"instruction": "They compose a coherent model.", "input": "The interplay of `exists`, `move_from`, `move_to`, and `borrow_global` forms:", "output": "A safe state management model"}
{"instruction": "Borrow first to check condition.", "input": "If you need conditional logic before removing a resource, such as only remove if a counter > 0:", "output": "Use borrow to inspect, then move"}
{"instruction": "Main motivation is safety.", "input": "The Move team chose a resource model to:", "output": "Ensure safe asset management"}
{"instruction": "Mutations apply to on-chain state.", "input": "After using `borrow_global_mut<T>(addr)`, modifications are:", "output": "Persist after commit"}
{"instruction": "The linear type system and VM checks enforce these invariants.\n\nBelow are questions 401\u2013600 focusing on the **Modules** category in Move. As before, each question includes a difficulty tag, category, four multiple-choice options, an answer, and a brief explanation.\n\n**Difficulty distribution for Modules:**  \n- 401\u2013450: Easy  \n- 451\u2013500: Medium  \n- 501\u2013600: Hard\n\n---\n\n### Modules (401\u2013450: Easy)", "input": "Ultimately, resources in Move ensure that critical invariants (like \u201cthis token cannot be duplicated\u201d):", "output": "Ensured by language-level checks"}
{"instruction": "Modules are usually defined within an `address` block indicating where they live.", "input": "A Move module is defined inside an `address` block as:", "output": "`address 0x1 { module M { ... } }`"}
{"instruction": "Modules group related declarations.", "input": "The `module` keyword introduces:", "output": "A named collection of code (structs, functions, etc.)"}
{"instruction": "Each module is uniquely identified by `address::ModuleName`.", "input": "Every module has a unique identifier composed of:", "output": "An address and a module name"}
{"instruction": "Modules are published at a specific on-chain address.", "input": "The address before the `module` declaration indicates:", "output": "The on-chain address of the module"}
{"instruction": "Modules are containers for various declarations.", "input": "Modules can contain:", "output": "Structs, functions, constants, and more"}
{"instruction": "The `public` keyword makes the function externally accessible.", "input": "To make a function callable from outside a module, use:", "output": "`public fun`"}
{"instruction": "Default visibility is private.", "input": "If a function is not marked `public`, it is:", "output": "Private to the module"}
{"instruction": "`const` defines a compile-time constant within a module.", "input": "Modules can have `const` declarations for:", "output": "Named compile-time constants"}
{"instruction": "Modules are stored on-chain at their specified address.", "input": "Modules are published on-chain by:", "output": "Via a publishing transaction"}
{"instruction": "The code of a published module is immutable to ensure consistency.", "input": "Once published, a module\u2019s code is:", "output": "Immutable"}
{"instruction": "Resources are special structs in modules with certain abilities.", "input": "Modules define resource types by using `struct` with abilities such as:", "output": "`has key, store` abilities"}
{"instruction": "External calls reference the module\u2019s address and name.", "input": "Calling a public function from another module requires:", "output": "Use the fully qualified address and module name"}
{"instruction": "Any public function can be called with the module\u2019s address and name.", "input": "A module can have multiple public functions, each accessible by:", "output": "By the fully qualified name"}
{"instruction": "`use` provides shorter paths to external items.", "input": "Can modules import functions from other modules?", "output": "Yes, `use` statements allow shorthand for referencing external modules"}
{"instruction": "Same fully qualified syntax applies for structs.", "input": "To access a struct defined in another module, you write:", "output": "`0x1::OtherModule::StructName`"}
{"instruction": "Modules encapsulate logic and data types.", "input": "Modules form the basic unit of:", "output": "Code organization and encapsulation"}
{"instruction": "Module names follow identifier naming conventions.", "input": "Each module\u2019s name must be:", "output": "A valid identifier"}
{"instruction": "Visibility must be explicitly granted.", "input": "By default, are module fields and functions visible to others?", "output": "No, need `public` keyword"}
{"instruction": "`public(friend)` restricts visibility to friend modules.", "input": "`public(friend)` visibility means:", "output": "Accessible only to friend modules"}
{"instruction": "The `friend` keyword followed by module address and name.", "input": "To declare a friend module:", "output": "`friend 0x1::OtherModule;`"}
{"instruction": "Friend modules can access `public(friend)` functions.", "input": "A `friend` relationship:", "output": "Provides selective visibility of internals to certain modules"}
{"instruction": "`spec` blocks define properties for formal verification.", "input": "Modules can contain `spec` blocks for:", "output": "Formal specification/verification"}
{"instruction": "`const` defines compile-time constants.", "input": "Constants in modules are defined with `const` and:", "output": "Known at compile time, immutable"}
{"instruction": "Verifier ensures module correctness before execution.", "input": "The bytecode of a module is checked by:", "output": "The Move VM\u2019s bytecode verifier"}
{"instruction": "`public(entry)` marks an entry function callable as a transaction script.", "input": "Modules can define entry functions by using:", "output": "fun main(...)`"}
{"instruction": "Allows module functions to be called like scripts.", "input": "Entry functions in a module can be invoked:", "output": "By a transaction referencing the entry function"}
{"instruction": "On-chain code storage.", "input": "Module code, once published, is stored:", "output": "In global storage at the module\u2019s specified address"}
{"instruction": "Addresses are hex-encoded.", "input": "The address in `address 0x1 { module M {...} }` is usually written as:", "output": "A hexadecimal literal (e.g., `0x1`)"}
{"instruction": "Public items define the module\u2019s interface.", "input": "Modules can provide a stable API by exposing:", "output": "Public functions/structs form the API"}
{"instruction": "The `as` keyword renames the imported module.", "input": "To rename imports (use shorter names), you can write:", "output": "`use 0x1::Vector as V;`"}
{"instruction": "Modules can define generic structs/functions.", "input": "A module can use generic type parameters for:", "output": "Functions and structs can be generic"}
{"instruction": "Visibility rules are checked by the VM.", "input": "The Move VM enforces module boundaries by:", "output": "Enforces privacy and boundaries"}
{"instruction": "Upgrading a module often means republishing under a new version.", "input": "To update a module (change its code), you must:", "output": "Deploy a new version (Move generally treats modules as immutable once published)"}
{"instruction": "Modules can define many types.", "input": "Modules can define multiple structs with different abilities to represent:", "output": "Multiple structs allowed"}
{"instruction": "Public items form the module\u2019s API.", "input": "The public interface of a module acts like:", "output": "An API"}
{"instruction": "`friend` extends module\u2019s internal visibility.", "input": "Modules can specify friend modules to allow:", "output": "Share some internals with friend modules"}
{"instruction": "Restricts access to a known set of friends.", "input": "If a module function is `public(friend)`, can anyone call it?", "output": "Only friend modules"}
{"instruction": "`public(entry)` marks functions callable as transaction entries.", "input": "A `public(entry)` function is:", "output": "An entry point for external calls via transactions"}
{"instruction": "Named addresses are a convenience for development.", "input": "Named addresses allow:", "output": "More readable and configurable addresses"}
{"instruction": "`self::` references the current module namespace.", "input": "Inside a module, to refer to its own items explicitly, you can use:", "output": "`self::`"}
{"instruction": "Move supports unit tests for modules.", "input": "Modules can be tested by:", "output": "Writing Move tests and running them with the Move testing tools"}
{"instruction": "Modules are uploaded via transactions.", "input": "Publishing a module requires:", "output": "A transaction publishing the compiled bytecode"}
{"instruction": "Modules orchestrate global storage interactions.", "input": "Modules can handle global storage operations like `move_from`, `move_to` to:", "output": "Manage on-chain resources"}
{"instruction": "Move source is compiled into bytecode.", "input": "Modules can be written in:", "output": "In Move language, then compiled"}
{"instruction": "Module definition block.", "input": "The `module` keyword is followed by the module\u2019s name and:", "output": "`{ ... }` block"}
{"instruction": "Modules provide encapsulation and organization.", "input": "To organize code, developers:", "output": "Group related items in one module"}
{"instruction": "Lazy loading at runtime as needed.", "input": "The VM loads a module from global storage when:", "output": "On-demand when needed"}
{"instruction": "Private functions are inaccessible outside the module.", "input": "If you try calling a private function from outside the module:", "output": "It fails verification"}
{"instruction": "Dependencies are explicit by referencing other modules.", "input": "Modules can depend on other modules by referencing:", "output": "Using `use` and fully qualified calls"}
{"instruction": "The VM ensures correctness and immutability prevents tampering.\n\n---\n\n### Modules (451\u2013500: Medium)", "input": "The integrity of a module\u2019s code is ensured by:", "output": "Verification and immutability"}
{"instruction": "`use` imports a module for shorter reference.", "input": "When calling `use 0x1::M;` inside a module, `M` refers to:", "output": "A module at address `0x1` named M"}
{"instruction": "Addresses can host multiple modules.", "input": "Can you have multiple modules at the same address?", "output": "Multiple modules can exist at the same address"}
{"instruction": "Public API controls resource creation.", "input": "If a module defines a resource type `R` and exposes a `public` function to create it, another module can:", "output": "Obtain `R` via the public constructor function"}
{"instruction": "Dependencies must be available on-chain.", "input": "The Move VM linker resolves module dependencies by:", "output": "Loads referenced modules from storage"}
{"instruction": "Move does not allow in-place upgrades easily.", "input": "If a module is upgraded by publishing a new module with the same name and address:", "output": "Module code is immutable; you must handle versioning yourself"}
{"instruction": "Modules enforce invariants via controlled APIs.", "input": "Modules often define invariant-preserving functions that ensure:", "output": "Ensuring resource invariants"}
{"instruction": "Visibility rules control who can manipulate resources.", "input": "Modules can control access to resources by:", "output": "Controlling the visibility and availability of resource-moving functions"}
{"instruction": "Acts like an entry point for external callers.", "input": "A `public(entry)` function in a module can be considered as:", "output": "Entry function callable as a transaction script"}
{"instruction": "Qualified by address and module name ensures uniqueness.", "input": "If two modules define structs with the same name, how are they distinguished?", "output": "`0x1::M::Struct` vs `0x2::M::Struct` differ by address"}
{"instruction": "`drop` relaxes linear usage constraints.", "input": "Modules can specify that a struct has the `drop` ability, allowing:", "output": "Drop ability allows discarding the value"}
{"instruction": "Private code enforces internal consistency.", "input": "A module\u2019s internal logic (private functions) helps maintain invariants by:", "output": "Encapsulating complex logic behind a safe public API"}
{"instruction": "`spec` is for formal verification conditions.", "input": "Modules can include `spec` language constructs to:", "output": "Write formal specifications"}
{"instruction": "On-chain upgrades require careful planning.", "input": "If a module changes its data structures, existing on-chain data:", "output": "Developer must handle migrations explicitly"}
{"instruction": "Multiple `public(entry)` funcs provide various transaction calls.", "input": "Modules can define multiple entry functions, meaning:", "output": "Many entry points possible"}
{"instruction": "Granular access control.", "input": "`public(friend)` functions are particularly useful when:", "output": "Share internal APIs with a limited set of friend modules"}
{"instruction": "Verification errors prevent module publication.", "input": "The verifier checks module bytecode for correctness. If an error is found:", "output": "Publication fails"}
{"instruction": "Constants are accessible by name within the module.", "input": "Within a module, a `const` can be accessed:", "output": "Direct name access"}
{"instruction": "Shared logic in modules is reused by external callers.", "input": "Modules promote code reuse by:", "output": "Public interfaces enable reuse"}
{"instruction": "Public API determines who can create the resource.", "input": "If a module defines a resource `Coin`, and provides a `public fun mint(...)`:", "output": "If `mint` is public, other modules/scripts can call it (unless restricted)"}
{"instruction": "`public(entry)` differs from `public` in usage context.", "input": "To avoid unintended usage, modules can restrict functions to `public(entry)` only when:", "output": "Entry functions are primarily for external transaction calls"}
{"instruction": "Global resource access controlled via Move instructions.", "input": "Modules can store references to global resources by:", "output": "Accessing global storage via built-in global ops"}
{"instruction": "Friendships are one-sided declarations.", "input": "A friend module relationship is declared:", "output": "The module declares who its friends are"}
{"instruction": "Nothing inherently prevents mutual friendship.", "input": "Circular friend declarations (two modules friend each other) are:", "output": "Allowed if consistent, but can lead to complex dependencies"}
{"instruction": "Named addresses can be used so you don\u2019t hardcode addresses in source.", "input": "If you omit address declaration and write `module M { ... }` alone:", "output": "Usually a named address is provided or defaulted by build configuration"}
{"instruction": "Development best practices.", "input": "Modules are typically organized in a codebase by:", "output": "Structured directories and named addresses for clarity"}
{"instruction": "Global storage requires `key`.", "input": "If a module tries to publish a resource that does not have `key` ability:", "output": "`move_to` aborts without `key`"}
{"instruction": "API stability is important for maintainability.", "input": "A module\u2019s public API stability matters because:", "output": "Clients rely on the stable interface"}
{"instruction": "Proper documentation is crucial.", "input": "Documentation for modules:", "output": "Comments and spec language provide documentation"}
{"instruction": "`use` statements can rename imports.", "input": "To rename a struct from an imported module:", "output": "`use` with `as`"}
{"instruction": "Modules can serve as reusable libraries.", "input": "If a module does not define any entry functions, can it still be useful?", "output": "It can be a library module"}
{"instruction": "Unit tests ensure correctness.", "input": "A module testing strategy might include:", "output": "Use the Move testing framework and test public functions"}
{"instruction": "Common resource modules become standard dependencies.", "input": "Modules that produce resources used by many other modules form:", "output": "Foundational libraries and standard modules"}
{"instruction": "No in-place upgrades, versioning is common.", "input": "When a module evolves over time, a typical approach is:", "output": "Versioning strategy, e.g., `0x1::ModuleV2`"}
{"instruction": "Modules have no auto-initialization; must be done explicitly.", "input": "The module initialization logic (if any) must be done:", "output": "By calling a function that initializes state"}
{"instruction": "Standard library modules provide reusable functions.", "input": "Modules can rely on code from standard library modules like `0x1::Vector`:", "output": "Import and use them as dependencies"}
{"instruction": "Generics specified with `<T>` syntax.", "input": "If a module defines a generic struct `struct Box<T>`, another module can instantiate it as:", "output": "`0x1::M::Box<u64>` referencing fully qualified name with type argument"}
{"instruction": "Modules define resource constructors as part of their API.", "input": "A module can provide a function that returns a resource:", "output": "Functions can return resources"}
{"instruction": "Tuples can be returned and unpacked by callers.", "input": "If a module function returns multiple values (a tuple), callers can:", "output": "Destructure the tuple return values"}
{"instruction": "Other modules can\u2019t call `public(entry)` functions directly, only transactions.", "input": "To ensure a module function is never called from another module (only from scripts), use:", "output": "`public(entry)` restricts to external transaction calls, not other modules\u2019 calls"}
{"instruction": "Private/internal utility modules.", "input": "Modules with no `public` or `public(entry)` functions:", "output": "They can be internal helpers for friend modules"}
{"instruction": "Move operations affect global on-chain state.", "input": "When a module\u2019s function calls `move_from` or `move_to`, it modifies:", "output": "Global storage"}
{"instruction": "API design controls resource lifecycle.", "input": "A module can prevent external resource destruction by:", "output": "Control `move_from` calls to prevent unauthorized resource removal"}
{"instruction": "Unit tests verify correctness.", "input": "Testing a module\u2019s logic often involves writing a Move test script that:", "output": "A test harness invokes module APIs with test scenarios"}
{"instruction": "Compose via explicit references and calls.", "input": "Modules can be composed to form larger systems by:", "output": "Modular composition through public interfaces"}
{"instruction": "Move uses abort codes for errors.", "input": "If a module needs to handle errors, it uses:", "output": "`abort <code>` for error handling"}
{"instruction": "Encapsulation of helper logic.", "input": "A module can define helper functions as `fun helper(...)` without `public`, so:", "output": "Private functions used internally"}
{"instruction": "Must fully qualify or `use` to bring `S` into scope.", "input": "If a module is at `0x1::M` and defines `struct S`, to use `S` in another module:", "output": "Import and reference fully qualified or via `use`"}
{"instruction": "Storage modifications are controlled and typed.", "input": "Updating global storage from a module function requires:", "output": "Correct abilities and global ops"}
{"instruction": "`signer` represents the transaction sender.", "input": "If a module\u2019s public function expects a `signer` argument:", "output": "Caller provides `signer`"}
{"instruction": "Verification ensures module correctness before execution.\n\n---\n\n### Modules (501\u2013600: Hard)", "input": "When verifying a module, the Move VM ensures:", "output": "Enforces type and resource safety"}
{"instruction": "Dependencies dynamically loaded from on-chain storage.", "input": "If a module is published at `0xA::M` and depends on `0xB::N`, when executing a function from `M` that calls `N`\u2019s function:", "output": "VM loads `N` from storage as needed"}
{"instruction": "Public API changes break callers.", "input": "If you refactor a module by renaming a public function, dependent modules:", "output": "They break; no automatic renaming"}
{"instruction": "Phantom types influence type system without storage overhead.", "input": "Modules can define phantom type parameters in structs, meaning:", "output": "Phantom type parameters affect abilities but no runtime fields"}
{"instruction": "Friend-only access is strictly enforced.", "input": "A module trying to call a `public(friend)` function of another module without being a friend:", "output": "Verification fails for unauthorized access"}
{"instruction": "Data stays under old module\u2019s namespace.", "input": "If a module publishes a resource `T` to global storage but later is upgraded (published as a new version under a different address or name), existing `T` instances:", "output": "They remain bound to the old module\u2019s address and name"}
{"instruction": "No automated migration; must handle manually.", "input": "To handle module upgrades involving data migrations, developers often:", "output": "Manual migration scripts"}
{"instruction": "Formal specs ensure correctness properties.", "input": "A module can expose a verification condition in `spec` that ensures:", "output": "`spec` conditions verify invariants"}
{"instruction": "Friend access extends to `public(friend)` elements, not private fields unless specified.", "input": "If two modules form a friend relationship but one tries to access private fields of a struct defined in the other without `friend` access:", "output": "Must have correct visibility for friend access"}
{"instruction": "Control creation by restricting constructors.", "input": "Modules cannot have cyclical dependencies where each directly depends on the other for:", "output": "No public creation functions means only the module\u2019s internal logic can create `R`"}
{"instruction": "Classic encapsulation principle.", "input": "Modules implement encapsulation by:", "output": "Private internals, public API"}
{"instruction": "Must adhere to abilities for storage.", "input": "If a module tries to store a non-`store` type in global storage, the verifier:", "output": "Verification fails"}
{"instruction": "Move is a statically resolved language.", "input": "To dynamically dispatch calls between modules (like polymorphism), Move:", "output": "No dynamic dispatch, all calls are statically known"}
{"instruction": "Verifier enforces correctness for all possible instantiations.", "input": "If a module defines multiple generic functions with complex constraints, the verifier checks:", "output": "The verifier ensures generics comply with declared abilities"}
{"instruction": "Move requires explicit upgrade strategies.", "input": "To provide a secure upgrade path for a widely used module, developers might:", "output": "Versioning and migration scripts"}
{"instruction": "Must respect borrow rules to avoid dangling references.", "input": "If a module function returns a reference to a global resource (`&T`), it:", "output": "Borrow rules ensure validity"}
{"instruction": "Invariants ensured by design and formal specs.", "input": "Modules can enforce complex invariants by combining:", "output": "Use resource and spec conditions"}
{"instruction": "The verifier enforces borrow rules.", "input": "If a module tries to call `borrow_global_mut<T>(addr)` twice at the same time:", "output": "Multiple simultaneous mutable borrows disallowed"}
{"instruction": "Encapsulation hides struct internals.", "input": "A module that wants to hide the implementation of a resource\u2019s fields can:", "output": "Private fields with controlled accessor functions"}
{"instruction": "Aborts propagate error codes.", "input": "If a module\u2019s `public` function aborts with a specific code, callers:", "output": "The abort code is observable by the caller"}
{"instruction": "Persistent modules vs ephemeral scripts.", "input": "Modules and scripts differ in that:", "output": "Modules persist on-chain, scripts are single-use"}
{"instruction": "Restricting mutable access ensures control.", "input": "To ensure no external module can modify a global resource defined by your module:", "output": "Control the API to prevent external modifications"}
{"instruction": "Specs guide formal verification.", "input": "If a module includes a `spec module { ... }` block with invariants:", "output": "The prover uses these specs for verification"}
{"instruction": "Storage layout must remain consistent.", "input": "If a module tries to `move_from<T>(addr)` where `T` is defined in another module that changed drastically:", "output": "Data layout is tied to original definition. Changes can cause incompatibility."}
{"instruction": "Backward compatibility demands planning.", "input": "A module ensuring backward compatibility with old data is challenging because:", "output": "Immutability requires careful versioning"}
{"instruction": "Proper API ensures token invariants.", "input": "To create a secure token standard, a module might define a `Coin` resource and:", "output": "Strict control over resource manipulation"}
{"instruction": "All dependencies must exist on-chain.", "input": "When linking modules at runtime, if a required dependency is missing:", "output": "Abort due to unresolved dependencies"}
{"instruction": "Generic constraints ensure correct usage.", "input": "A module can define functions parameterized by abilities on type parameters, like `fun f<T: drop>(x: T)`. This means:", "output": "`T` must implement `drop`"}
{"instruction": "Controlled read access, restricted write/create access.", "input": "If a module wants to prevent external creation of a resource, but allow external reading of a field:", "output": "Provide getters without setters/constructors"}
{"instruction": "No second mutable borrow allowed.", "input": "If a module uses `borrow_global_mut` and holds the mutable reference while calling another module\u2019s function that tries `borrow_global_mut` on the same resource:", "output": "Borrow conflict prevents it"}
{"instruction": "Abilities and `Vector` module facilitate complex data.", "input": "Modules can store complex data structures like `vector` of resources by:", "output": "`store` ability for nested resources and `Vector` operations"}
{"instruction": "Generic instantiation requires matching constraints.", "input": "If a module defines a struct with multiple type parameters and abilities, the caller must:", "output": "Must supply compatible type parameters"}
{"instruction": "All types are statically known, no reflection.", "input": "Modules enforce no runtime reflection or introspection, meaning:", "output": "No runtime type introspection"}
{"instruction": "Formal specs guide verification, not runtime.", "input": "For formal verification, a module\u2019s `spec` can detail function preconditions using `requires` clauses, meaning:", "output": "Precondition checks by the prover"}
{"instruction": "Consistent storage formats are simpler long-term.", "input": "A module\u2019s resource that never changes in structure (stable schem", "output": "Stable schema avoids migration complexity"}
{"instruction": "Address and module name disambiguate.", "input": "If two modules both define a function named `init`, to call `init` from module `N` inside module `M`:", "output": "Must fully qualify with `0xN::N::init()` if calling from `M`"}
{"instruction": "Publishing resources requires signer authorization.", "input": "If a module tries to publish a resource under a signer address different from any provided signers:", "output": "Must have a `signer` referencing that address to publish resources there"}
{"instruction": "Formal methods ensure correctness.", "input": "Modules can integrate with formal verification tools to ensure:", "output": "Prover checks all stated properties"}
{"instruction": "Authenticated calls need signers.", "input": "If a module\u2019s `public(entry)` function expects a `signer` to prove authorization, calling it without such a signer:", "output": "VM requires a signer for `signer` parameters"}
{"instruction": "Capability-based security patterns.", "input": "Modules might represent capabilities (like permission tokens) as resources. By controlling who can `move_from` these capabilities:", "output": "Restricting `move_from` and `move_to` enforces security"}
{"instruction": "Friend modules for testing internal details.", "input": "If you rely on friend modules for testing private logic, you can:", "output": "Friend test modules can access internal APIs"}
{"instruction": "Changes can break downstream dependencies.", "input": "Breaking changes to a widely used module\u2019s public API:", "output": "Clients depend on API stability"}
{"instruction": "`key` required for global publishing.", "input": "If a module tries to `move_to` a resource at an address without `key` ability:", "output": "Abort occurs"}
{"instruction": "Compiler optimizations preserve semantics.", "input": "Modules can define helper functions that are inlined by the compiler for efficiency, but:", "output": "Inlining doesn\u2019t change semantics, just performance"}
{"instruction": "Assertions ensure runtime conditions.", "input": "If a module uses `assert` to enforce conditions at runtime:", "output": "`assert` leads to abort on failure"}
{"instruction": "Versioning within data structures.", "input": "A module that needs to evolve its resource layout over time might:", "output": "Store version info and handle old formats gracefully"}
{"instruction": "Public struct \u2260 public fields by default.", "input": "If a resource struct is made public, does it mean all its fields are public?", "output": "Struct visibility and field visibility differ"}
{"instruction": "Constants must be determined at compile time.", "input": "Modules can define constants of any supported type, including addresses and integers. If a constant references another module\u2019s constant:", "output": "Compile-time known constants require dependencies to be available"}
{"instruction": "Borrow rules checked at compile/verify time.", "input": "If a module tries to `borrow_global_mut` a resource multiple times without ending the first borrow:", "output": "Verifier ensures no multiple mutable borrows"}
{"instruction": "Specs guide the prover, not runtime.", "input": "A module can rely on `spec` language to:", "output": "Formal verification conditions"}
{"instruction": "Multiple ability constraints must be met.", "input": "If a module defines a complex generic function `fun f<T: key + store>`:", "output": "Requires both abilities"}
{"instruction": "No semantic changes.", "input": "To optimize module code, developers might rely on the Move compiler\u2019s optimizations, but must remember:", "output": "Optimizations are semantics-preserving"}
{"instruction": "Must check `exists` first or handle abort.", "input": "If a module tries to `move_from` a resource type that does not exist at the given address:", "output": "Abort on non-existent resource"}
{"instruction": "Static checks ensure reference safety.", "input": "If a module function returns a reference to a resource, the caller must not outlive the reference\u2019s validity:", "output": "Borrow rules prevent dangling refs"}
{"instruction": "Control upgrades via data-driven logic.", "input": "Modules can represent upgrades by storing a `GlobalConfig` resource with version info and using entry functions to:", "output": "Runtime logic to handle versions"}
{"instruction": "Implement address checks at runtime.", "input": "If a module wants to enforce that only the address that published it can call a certain function:", "output": "Authorization logic in the function body"}
{"instruction": "Complex structures still follow strict rules.", "input": "Complex resource graphs (resources referencing other resources inside vectors) are managed by:", "output": "All must adhere to linear usage and `store` abilities"}
{"instruction": "Specs help identify logical errors before deployment.", "input": "If a module\u2019s `spec` invariants fail under certain inputs:", "output": "Prover reports violation at verification time"}
{"instruction": "Parametric polymorphism replaces inheritance.", "input": "Without dynamic dispatch, modules emulate polymorphism by:", "output": "Generics and abilities for parametric polymorphism"}
{"instruction": "Must design code so no abort path is taken.", "input": "If a module function must never abort, developers can:", "output": "Careful logic and checks to prevent abort"}
{"instruction": "Storage and computation cost matter.", "input": "Modules can store large data structures on-chain, but must consider:", "output": "Gas and performance implications"}
{"instruction": "Mutations persist if no abort.", "input": "If a module defines a function that takes `&mut T` from global storage and modifies it:", "output": "On-chain state updated upon successful transaction"}
{"instruction": "Good design aids correctness and maintainability.", "input": "A module with a carefully designed API and formal specs:", "output": "Improved reasoning and verification"}
{"instruction": "API design ensures presence.", "input": "If you need to ensure a resource is always present at a specific address, the module might:", "output": "Control lifecycle so resource never removed"}
{"instruction": "Shared storage at addresses and public APIs.", "input": "If two modules want to share state, they can:", "output": "Collaborate through shared global storage and calls"}
{"instruction": "Invariants enforced by checks.", "input": "To enforce that a resource\u2019s field is never set to a negative number:", "output": "Include runtime checks and abort on invalid states"}
{"instruction": "Modularization improves readability and maintainability.", "input": "If a module\u2019s code grows too large and complex:", "output": "Decompose into smaller modules"}
{"instruction": "Verification ensures predictable behavior.", "input": "Formal verification can prove that a module\u2019s public functions never abort if given certain preconditions. This:", "output": "Gives strong correctness guarantees"}
{"instruction": "Addresses are access-controlled.", "input": "If a module tries to `move_to` a resource under a different signer\u2019s address than the transaction signer:", "output": "Must have proper authorization or fails"}
{"instruction": "Signer indicates transaction sender\u2019s identity.", "input": "Modules use `signer` parameters to:", "output": "`signer` proves authorization"}
{"instruction": "Prevent misuse of generic types.", "input": "Ability constraints on generics in modules ensure:", "output": "Compile-time enforced ability constraints"}
{"instruction": "Manual enforcement of invariants across multiple resources.", "input": "Complex invariants might involve multiple resources. A module can enforce them by:", "output": "Carefully placing checks in relevant functions"}
{"instruction": "`store` ability is needed for nested storage.", "input": "If a resource is defined as `struct R has store { x: u64 }` in a module, other modules can store `R` inside their resources if:", "output": "`store` allows nesting in other stored resources"}
{"instruction": "Removal of a public function breaks callers.", "input": "If you remove a `public` function from a module and republish it (under a new address), old code calling that function:", "output": "Breaks compatibility"}
{"instruction": "Structural changes need migration.", "input": "Modules and their resource layouts form a contract with clients. Changing resource fields:", "output": "Must handle old data or break invariants"}
{"instruction": "Prover guarantees correctness given specs.", "input": "If a module\u2019s function `f` is proven never to abort by the Move Prover:", "output": "Formal proofs ensure correctness under assumptions"}
{"instruction": "Error codes convey reason for abort.", "input": "Modules can define custom error codes for `abort`:", "output": "Distinguish error types by different abort codes"}
{"instruction": "Mut borrow excludes `move_from`.", "input": "If a module holds a `&mut T` reference and calls another module\u2019s function that tries `move_from<T>(...)`:", "output": "Conflicting operations not allowed"}
{"instruction": "A well-designed stable library.", "input": "To create a stable and trusted library, a module should:", "output": "Stability, documentation, verification"}
{"instruction": "No drop/copy means strict linear usage.", "input": "If a module defines a type with no `copy` and no `drop`:", "output": "Full linearity required"}
{"instruction": "Capabilities model restricted permissions.", "input": "A module can implement \u201ccapabilities\u201d by:", "output": "Capability resources passed to authorized callers"}
{"instruction": "Removing friendship breaks friend access.", "input": "If a friend module relationship is removed in a new module version:", "output": "Updated version changes visibility"}
{"instruction": "Specs can reason about state transitions.", "input": "Modules can define `public(entry)` functions that do global state changes, and formal verification can:", "output": "Verify invariant preservation even after global changes"}
{"instruction": "Careful planning required.", "input": "If a module\u2019s data model changes drastically, a recommended approach:", "output": "Versioned migration strategy"}
{"instruction": "Generic constraints must hold.", "input": "Modules that rely on complex generic types must ensure:", "output": "Verification enforces constraints"}
{"instruction": "Entry points as controlled gateways.", "input": "To reduce the risk of misuse, a module can provide only `public(entry)` functions that:", "output": "Entry functions handle permission checks"}
{"instruction": "Verification increases trust.", "input": "If formal verification proves all `public` functions preserve invariants, the module:", "output": "Higher confidence in correctness"}
{"instruction": "Modular composition is key to building complex systems.", "input": "Modules interacting across different addresses form a decentralized ecosystem where:", "output": "A composable on-chain ecosystem"}
{"instruction": "API stability is crucial.", "input": "If a module is heavily relied upon, changing its `public` API drastically requires:", "output": "Breaks backward compatibility, need careful communication"}
{"instruction": "Abort codes are arbitrary integers.", "input": "If a module tries to `abort` with a code not defined as a constant:", "output": "Any integer code is allowed"}
{"instruction": "Limit external access to reduce attack surface.", "input": "Modules can improve security by:", "output": "Least privilege and careful exposure of APIs"}
{"instruction": "If no removal is exposed, it stays forever.", "input": "If a module defines a resource `R` and no `public` or `public(entry)` function can remove `R` from global storage:", "output": "Permanent until some allowed operation removes it"}
{"instruction": "Capabilities as resources.", "input": "Complex capability patterns (like delegation) can be implemented by:", "output": "Capability resources model delegations"}
{"instruction": "Code and specs ensure limits.", "input": "A module can limit the number of instances of a resource type by:", "output": "Logic and invariants enforce scarcity"}
{"instruction": "Formal proofs provide high assurance, though assumptions matter.", "input": "If formal verification finds no counterexample to invariants:", "output": "Strong confidence in correctness"}
{"instruction": "Modular specification.", "input": "Modules can define multiple `spec` blocks:", "output": "Multiple specs for various components"}
{"instruction": "Manual migration pattern.", "input": "Migrating data between module versions can use patterns like:", "output": "Explicit migration process"}
{"instruction": "Determinism is key for blockchain predictability.", "input": "Modules and their bytecode are deterministic, meaning:", "output": "Deterministic execution"}
{"instruction": "Good design pays off.", "input": "A well-structured module with formal specs and careful API design is:", "output": "Improves maintainability, verification, and composability"}
{"instruction": "Core purpose of Move modules.\n\n\nBelow are questions 601\u2013800 focusing on the **VM** (Move Virtual Machine) category in Move. As before, each question includes difficulty tags, category, four multiple-choice options, the correct answer, and a brief explanation.\n\n**Difficulty distribution for VM:**  \n- 601\u2013650: Easy  \n- 651\u2013700: Medium  \n- 701\u2013800: Hard\n\n---\n\n### VM (601\u2013650: Easy)", "input": "Ultimately, Move modules provide a foundation for:", "output": "Safe, composable, invariant-rich blockchain applications"}
{"instruction": "The Move VM executes compiled Move bytecode.", "input": "The Move VM is responsible for executing:", "output": "Move bytecode instructions"}
{"instruction": "The verifier ensures no illegal operations or type safety violations.", "input": "Before execution, the Move VM runs a **verifier** to:", "output": "Check bytecode for safety and correctness"}
{"instruction": "The VM interacts with the blockchain\u2019s global storage of resources.", "input": "The Move VM operates on data stored:", "output": "On-chain global storage"}
{"instruction": "The VM\u2019s runtime checks and verifier ensure resource invariants.", "input": "The Move VM enforces resource safety by:", "output": "Preventing illegal operations on resources"}
{"instruction": "VM isolates and safely executes Move bytecode.", "input": "To execute a transaction script or a module function, the VM:", "output": "Loads bytecode and runs it in a sandbox"}
{"instruction": "Determinism is crucial for blockchain consensus.", "input": "The Move VM ensures deterministic execution by:", "output": "Removing non-deterministic operations"}
{"instruction": "Verification is mandatory before execution.", "input": "If code fails verification, the VM:", "output": "Refuses to run non-verified code"}
{"instruction": "Similar to many bytecode VMs.", "input": "The VM uses a stack-based execution model, meaning:", "output": "Stack-based bytecode execution"}
{"instruction": "Gas limits prevent denial-of-service attacks.", "input": "Gas in the Move VM context is:", "output": "A cost mechanism to ensure resource limits"}
{"instruction": "Every operation in the VM has a gas cost.", "input": "When a transaction runs, the VM charges gas for:", "output": "Execution and resource usage incur gas costs"}
{"instruction": "Transactions are atomic; abort means no persistent changes.", "input": "If execution aborts (e.g., via `abort <code>`), the VM:", "output": "All effects of the failed transaction are reverted"}
{"instruction": "On-chain modules are loaded by address.", "input": "The Move VM links modules:", "output": "From global storage when needed"}
{"instruction": "Designed for blockchain execution.", "input": "The Move VM\u2019s primary purpose in a blockchain context is to:", "output": "Execute Move-based smart contracts"}
{"instruction": "Borrow checking prevents unsafe aliasing.", "input": "At runtime, the VM ensures reference safety by:", "output": "Enforcing static and dynamic checks"}
{"instruction": "Carefully chosen instruction set for on-chain logic.", "input": "The VM\u2019s bytecode instructions include operations for:", "output": "Basic ops plus global storage primitives"}
{"instruction": "Ensures consensus consistency.", "input": "The VM runs inside nodes of a blockchain network, ensuring:", "output": "Deterministic execution across all nodes"}
{"instruction": "No unsafe pointer operations.", "input": "The Move VM memory model:", "output": "Strict memory rules ensure safety"}
{"instruction": "Costs determined by a pricing model.", "input": "Move VM gas costs are set by:", "output": "A known cost table"}
{"instruction": "Safety checks prevent out-of-bound access.", "input": "If a script attempts an out-of-bound index on a vector, the VM:", "output": "Aborts the transaction"}
{"instruction": "Simplicity aids security and correctness.", "input": "The VM is designed to be:", "output": "Minimal, secure, and correct"}
{"instruction": "Entry functions act like scripts.", "input": "When the VM executes a `public(entry)` function from a module:", "output": "Functions as a transaction entry function"}
{"instruction": "Prevents unintended overflow bugs.", "input": "The VM ensures integer overflow aborts rather than wraps by:", "output": "Runtime checks cause abort on overflow"}
{"instruction": "Ensures transactional integrity.", "input": "The VM\u2019s execution of a script or entry function is:", "output": "Atomic transaction semantics"}
{"instruction": "Stability ensures on-chain contracts remain valid.", "input": "The Move VM bytecode format is stable, meaning:", "output": "Generally stable to avoid breaking on-chain code"}
{"instruction": "Special instructions handle on-chain resources.", "input": "The VM interacts with global storage by instructions like:", "output": "Built-in global storage instructions"}
{"instruction": "All references must be valid at creation.", "input": "The VM ensures no null references because:", "output": "Move\u2019s type system prevents null"}
{"instruction": "Simplicity and determinism are key.", "input": "The VM execution model is:", "output": "Deterministic, single-threaded model"}
{"instruction": "`abort <code>` signals errors.", "input": "Errors in Move code appear as:", "output": "Aborts with a code"}
{"instruction": "Avoids denial-of-service attacks.", "input": "The VM\u2019s gas mechanism ensures:", "output": "Costs must be covered by gas"}
{"instruction": "Moves user logic execution on-chain.", "input": "The Move VM is typically integrated into a blockchain node to:", "output": "Process on-chain transactions"}
{"instruction": "Verifier ensures bytecode correctness.", "input": "Verifier checks include:", "output": "Enforces language and safety rules"}
{"instruction": "Borrow rules enforced at verification.", "input": "If an instruction tries to borrow a mutable reference while another mutable reference exists, the VM:", "output": "Bytecode fails verification or aborts if it occurs at runtime"}
{"instruction": "Small instruction set for simplicity.", "input": "The VM\u2019s instruction set is:", "output": "Minimal, security and correctness focused"}
{"instruction": "Floating-point can introduce non-determinism.", "input": "The VM does not allow floating-point arithmetic to:", "output": "Determinism requires no floating-point non-determinism"}
{"instruction": "Safety violations cause aborts.", "input": "Move VM operations that fail runtime checks:", "output": "Abort transaction"}
{"instruction": "Move uses a simple type system.", "input": "The VM\u2019s data model is based on:", "output": "Simple, statically typed model"}
{"instruction": "Gas prevents infinite loops or long computations without payment.", "input": "To handle large computations, the VM:", "output": "Gas ensures termination or abort"}
{"instruction": "References are carefully controlled.", "input": "The VM\u2019s reference model ensures:", "output": "Safe mutation with controlled references"}
{"instruction": "Storage operations cost gas.", "input": "Storage accesses are potentially expensive. The VM:", "output": "Gas model includes storage access costs"}
{"instruction": "Abort codes communicate error types.", "input": "The VM\u2019s error codes in `abort` help developers:", "output": "Error codes let callers handle or log errors"}
{"instruction": "Prevents free computation beyond gas limit.", "input": "If a transaction runs out of gas mid-execution, the VM:", "output": "Running out of gas aborts"}
{"instruction": "Code immutability ensures stable contracts.", "input": "The VM ensures that once published, a module\u2019s code is:", "output": "Immutable"}
{"instruction": "Stack-based model for calls.", "input": "During execution, the VM maintains a call stack for:", "output": "Like many VMs, uses a call stack for function calls"}
{"instruction": "Ensures safety and no malicious bytecode.", "input": "All code run by the VM must pass the verifier, ensuring no:", "output": "Only verified code executes"}
{"instruction": "No external non-deterministic sources.", "input": "The VM is deterministic given:", "output": "Deterministic execution for consensus"}
{"instruction": "Access checks required before borrowing or moving.", "input": "If a script tries to access a resource that doesn\u2019t exist, the VM:", "output": "Non-existent resource access aborts"}
{"instruction": "Type safety enforced.", "input": "The VM\u2019s type checking prevents:", "output": "Strict type checks ensure correct usage"}
{"instruction": "The VM focuses on code execution, not blockchain networking.", "input": "The VM is not responsible for:", "output": "Networking/consensus is outside VM scope"}
{"instruction": "Safety first.", "input": "The VM aborts execution on invalid operations to maintain:", "output": "Abort ensures no unsafe state changes"}
{"instruction": "Blockchain constraints shape VM design.\n\n---\n\n### VM (651\u2013700: Medium)", "input": "The Move VM\u2019s design is heavily influenced by:", "output": "Tailored for on-chain secure computation"}
{"instruction": "Verification is a compile-time/static check.", "input": "The Move VM bytecode verifier uses static analysis to ensure:", "output": "Static analysis prevents illegal states"}
{"instruction": "Proper linking ensures code correctness at runtime.", "input": "The VM\u2019s loader links modules by:", "output": "It ensures all dependencies are resolved"}
{"instruction": "Prevents double-spend and resource duplication.", "input": "The VM enforces the global uniqueness of resources by:", "output": "Ensures only one instance of a resource type per address"}
{"instruction": "Borrow rules enforced at runtime/verification.", "input": "During execution, the VM keeps track of references to ensure:", "output": "Strict reference rules"}
{"instruction": "Continuous gas accounting ensures no free lunch.", "input": "Gas metering in the VM is done by:", "output": "Instruction-by-instruction metering"}
{"instruction": "Verified code only.", "input": "If a transaction tries to publish a module that fails verification:", "output": "Rejects and aborts"}
{"instruction": "Simpler machine model is easier to analyze.", "input": "The VM\u2019s stack machine architecture simplifies:", "output": "Stack-based bytecode is easier to verify and reason about"}
{"instruction": "Static checks prevent invalid runtime refs.", "input": "Move VM\u2019s reference lifetime rules are checked:", "output": "Verifier ensures correct reference use"}
{"instruction": "On-chain storage is a separate model.", "input": "The VM\u2019s global storage operations (`move_from`, `move_to`, `borrow_global`) are special because:", "output": "Persistent storage requires special handling and costs"}
{"instruction": "Spec-defined format for consistency.", "input": "The VM\u2019s binary format for modules and scripts is defined in the Move language specification, ensuring:", "output": "A stable, standardized bytecode format"}
{"instruction": "Atomicity ensures consistency.", "input": "If a transaction script fails after partially modifying local data:", "output": "No partial commits, atomic rollback"}
{"instruction": "Type/ability constraints are enforced strictly.", "input": "The VM ensures ability constraints for generic types, meaning:", "output": "Enforces constraints at verification"}
{"instruction": "No undefined behavior; abort on error.", "input": "If the VM encounters a divide-by-zero operation:", "output": "Arithmetic errors lead to aborts"}
{"instruction": "Proper linking prevents runtime errors.", "input": "The VM\u2019s linking process ensures that:", "output": "Static linking ensures no missing dependencies at runtime"}
{"instruction": "VM is chain-agnostic with a defined API.", "input": "The VM can be embedded into different blockchain frameworks by:", "output": "Provides a generic interface"}
{"instruction": "Core instructions for structured data handling.", "input": "Move bytecode instructions like `call`, `pack`, `unpack` manage:", "output": "Function calls and struct operations"}
{"instruction": "Linear types maintain scarcity.", "input": "The VM enforces linear typing of resources by:", "output": "Strict enforcement prevents resource duplication"}
{"instruction": "Sandbox execution with limited operations.", "input": "The Move VM runtime environment does not provide direct API calls to:", "output": "No external I/O or system calls"}
{"instruction": "VM just returns the abort code.", "input": "To handle complex error scenarios, developers assign distinct abort codes, and the VM:", "output": "Caller decides how to interpret codes"}
{"instruction": "Resource use correlates with gas cost.", "input": "For large global storage updates, the VM:", "output": "Big updates cost more gas"}
{"instruction": "Generic constraints must hold at instantiation time.", "input": "The VM\u2019s handling of generics ensures at runtime that:", "output": "Enforced ability constraints at runtime link"}
{"instruction": "Impossible to compile such code.", "input": "If a function tries to return a reference to a local value that will go out of scope:", "output": "Static verification prevents dangling references"}
{"instruction": "Strict memory model ensures safety.", "input": "The Move VM\u2019s design avoids dynamic memory allocation patterns like:", "output": "No unbounded heap pointers without checks"}
{"instruction": "Atomicity across the entire transaction.", "input": "In case of complex transactions with multiple calls, the VM:", "output": "All changes applied if final result is success, else rollback"}
{"instruction": "Off-chain tooling ensures code quality.", "input": "The VM\u2019s bytecode is designed to be verifiable off-chain before submission, meaning:", "output": "Pre-verification by developers is possible"}
{"instruction": "Prevents silent corruption.", "input": "The VM ensures integer arithmetic is safe by:", "output": "Checked arithmetic aborts on failure"}
{"instruction": "Consistency in stored data is crucial.", "input": "If a module changes its struct layout but old data still exists on-chain:", "output": "Must maintain compatibility or fail"}
{"instruction": "Separation of execution and consensus layers.", "input": "The VM is independent of consensus, meaning:", "output": "VM doesn\u2019t handle consensus logic"}
{"instruction": "Strict borrow rules prevent races.", "input": "The VM\u2019s memory safety rules are similar to Rust\u2019s borrow checker in that:", "output": "Borrowed from Rust\u2019s safety principles"}
{"instruction": "Ensures correct function calls.", "input": "When linking a module that references another module\u2019s function:", "output": "Full compatibility check"}
{"instruction": "Fair and consistent gas pricing.", "input": "The Move VM\u2019s deterministic gas cost model ensures:", "output": "Same cost on all nodes"}
{"instruction": "`signer` gives access to the sender\u2019s address.", "input": "The VM treats `signer` values as:", "output": "Special authenticated type"}
{"instruction": "Type correctness ensured at verification.", "input": "If a verified module tries to call a function with incorrect argument types at runtime:", "output": "Verifier ensures no such invalid call can appear in bytecode"}
{"instruction": "Simpler model for deterministic behavior.", "input": "The VM\u2019s approach to concurrency:", "output": "Single-threaded execution model"}
{"instruction": "Must handle all resources linearly.", "input": "If a resource is moved out of global storage and not replaced, after the transaction:", "output": "Resource linearity enforced"}
{"instruction": "Abilities checked at runtime operations.", "input": "The VM enforces the `key` ability for resources in global storage by:", "output": "Preventing storage of non-`key` resources"}
{"instruction": "Minimal VM-level error mechanism.", "input": "The VM\u2019s approach to error handling (abort codes) is minimal because:", "output": "Just provides a code, no complex handling"}
{"instruction": "No reflection for security and predictability.", "input": "Move VM does not allow reflection or runtime type inspection because:", "output": "Reflection complicates determinism"}
{"instruction": "Visibility determines who can call what.", "input": "The VM distinguishes `public`, `public(friend)`, and `public(entry)` by:", "output": "Visibility rules enforced at call time"}
{"instruction": "VM is chain-agnostic, storage is an interface.", "input": "The VM\u2019s global state access is abstracted so that:", "output": "Abstraction allows portability"}
{"instruction": "Generic vector operations handle complexity.", "input": "Complex data like `vector<vector<u8>>` is handled by the VM by:", "output": "Uniform treatment of nested types"}
{"instruction": "Borrow rules apply to container elements too.", "input": "The VM ensures that once a mutable reference to a vector element is taken:", "output": "Ensures uniqueness of mutable references"}
{"instruction": "Ensures determinism.", "input": "The VM\u2019s instruction set carefully avoids instructions that:", "output": "No non-deterministic external dependencies"}
{"instruction": "Caller can destructure results.", "input": "When a module function returns multiple values, the VM:", "output": "Multiple return values placed on stack"}
{"instruction": "Rejects suspicious bytecode at load time.", "input": "To prevent code injection or malicious bytecode, the VM:", "output": "Verification ensures no malicious structures"}
{"instruction": "VM doesn\u2019t magically handle compatibility.", "input": "The VM deals with backward compatibility by:", "output": "Developer-managed compatibility"}
{"instruction": "Same input -> same output on all nodes.", "input": "The VM\u2019s deterministic final state ensures consensus because:", "output": "Determinism is key for consensus"}
{"instruction": "Standard format aids ecosystem tools.", "input": "The VM uses a well-defined binary format so tools:", "output": "Encourages tooling and static analysis"}
{"instruction": "Costs are a policy detail, not code logic.", "input": "Gas costs can be adjusted by:", "output": "The gas schedule is a separate configuration"}
{"instruction": "All dependencies must exist on-chain.\n\n---\n\n### VM (701\u2013800: Hard)", "input": "If a transaction tries to load a non-existent module:", "output": "Missing dependencies cause abort"}
{"instruction": "Verification uses abstract interpretation for safety.", "input": "The Move VM\u2019s verification uses a stack of abstract states to:", "output": "Abstract interpretation ensures correctness"}
{"instruction": "VM expects a storage interface from host.", "input": "The VM\u2019s global storage API is typically provided by:", "output": "Integrator provides the global storage backend"}
{"instruction": "Correctness of generic instantiation is verified.", "input": "When linking generics, the VM checks that:", "output": "Abilities must match generic constraints"}
{"instruction": "Linear resources must remain valid.", "input": "The VM and verifier ensure no partial moves leave a resource in an invalid state by:", "output": "Must handle all fields correctly or abort"}
{"instruction": "Formal methods rely on exact definitions.", "input": "To support formal verification, the VM\u2019s semantics are:", "output": "A well-defined operational semantics"}
{"instruction": "Atomic execution model.", "input": "Move VM ensures transaction atomicity by:", "output": "Commit or rollback at the end"}
{"instruction": "Verification forbids cyclical type structures.", "input": "If a resource cycle was possible (e.g., resource A contains B and B contains A), the VM:", "output": "Cycles in resource struct definitions are disallowed"}
{"instruction": "Borrow checking prevents aliasing.", "input": "The VM\u2019s reference rules prevent aliasing a mutable reference by ensuring:", "output": "Exclusive mutable references"}
{"instruction": "No resource leaks allowed.", "input": "The VM\u2019s code paths must ensure that every resource:", "output": "Full accounting of resources"}
{"instruction": "Stack operations must be safe.", "input": "The verifier ensures no instruction accesses stack elements out of range by:", "output": "Static checks prevent stack underflow/overflow"}
{"instruction": "Avoiding breaking on-chain code is crucial.", "input": "To maintain forward compatibility, the VM:", "output": "Stability and versioning for backward compatibility"}
{"instruction": "Only friend modules can call friend functions.", "input": "If a module has a `public(friend)` function and another non-friend tries to call it:", "output": "Enforces visibility rules at runtime"}
{"instruction": "Designed for efficiency in verification.", "input": "For large codebases, the VM verifier\u2019s complexity:", "output": "Simplicity of instructions keeps verification tractable"}
{"instruction": "On-chain logic must be deterministic.", "input": "The VM does not directly support external calls because:", "output": "External calls could introduce non-determinism"}
{"instruction": "Gas is a policy separate from code logic.", "input": "If an updated gas schedule makes certain instructions more expensive:", "output": "Cost changes, behavior stays the same"}
{"instruction": "Resource uniqueness enforced.", "input": "The VM ensures that `move_from<T>(addr)` removes exactly one `T` resource if present, by:", "output": "The resource model guarantees at most one instance per type/address"}
{"instruction": "VM doesn\u2019t handle schema migrations automatically.", "input": "To handle upgrades to data structures, developers often write migration scripts that:", "output": "Manual migration ensures safe transitions"}
{"instruction": "No floating point for determinism and verifiability.", "input": "The VM\u2019s lack of floating point arithmetic:", "output": "Integers only simplifies verification and determinism"}
{"instruction": "Full dependency resolution is mandatory.", "input": "If a module or script fails linking due to missing dependencies:", "output": "Linking errors cause abort"}
{"instruction": "One mutable ref at a time.", "input": "The VM\u2019s instruction `borrow_global_mut<T>(addr)` ensures exclusive mutable access by:", "output": "Enforces exclusive mutability"}
{"instruction": "Type checks done at compile/link time.", "input": "The VM\u2019s approach to generics is erasure-based, meaning:", "output": "Generics checked statically, minimal runtime overhead"}
{"instruction": "No unused resources allowed.", "input": "If a resource does not have `drop` ability and is not stored or returned, the VM:", "output": "Resource linearity violation causes abort"}
{"instruction": "Authorization enforced at runtime.", "input": "The VM prevents cross-address resource moves (i.e., you can\u2019t `move_to` a resource at a different address without a signer) by:", "output": "Must have signer permission to place resource under that address"}
{"instruction": "Verification often uses IRs easier to reason about.", "input": "For formal verification, the VM\u2019s stack-based semantics are often translated into:", "output": "IR for verification tools like the Move Prover"}
{"instruction": "Strict borrow rules.", "input": "The VM disallows taking mutable references from multiple separate `borrow_global_mut` calls to the same resource concurrently:", "output": "Maintains consistency and safety"}
{"instruction": "Formal proofs rely on correct specs and assumptions.", "input": "If a function is supposed to never abort (proved by Move Prover), and at runtime it would abort:", "output": "Proof depends on assumptions; a violation means an assumption wasn\u2019t met"}
{"instruction": "Determinism aids auditing and trust.", "input": "The VM\u2019s deterministic execution model allows third-party auditors to:", "output": "Off-chain replication of results"}
{"instruction": "On-chain code permanence.", "input": "When a module is published, the VM stores it:", "output": "On-chain storage at module\u2019s address"}
{"instruction": "Ability constraints enforced.", "input": "The VM ensures that a generic function `fun f<T: key>(...)` can only be instantiated with types that have `key` by:", "output": "Verifier enforces correct instantiations"}
{"instruction": "Many events can trigger aborts.", "input": "The VM\u2019s abort conditions can be triggered by:", "output": "Both explicit `abort` and runtime safety checks"}
{"instruction": "Ownership rules make memory management deterministic.", "input": "The VM\u2019s memory model does not rely on garbage collection because:", "output": "Linear typing eliminates the need for GC"}
{"instruction": "Data layout is critical; no silent conversions.", "input": "If a module\u2019s struct fields change order, old stored data:", "output": "Layout changes require careful handling"}
{"instruction": "Layout must match exactly.", "input": "The VM\u2019s verifications ensure no `unpack` on a struct with fewer fields than required:", "output": "Exact matching enforced by verifier"}
{"instruction": "Unique names per module.", "input": "If a transaction tries to publish a module with a duplicate struct definition:", "output": "No duplicates allowed"}
{"instruction": "Multi-module invariants rely on formal verification at design time.", "input": "Complex invariants spanning multiple modules can be reasoned about by:", "output": "Combine formal specs and deterministic execution"}
{"instruction": "Trustless environment.", "input": "The VM\u2019s execution environment does not trust module code a priori because:", "output": "Verification replaces trust in authors"}
{"instruction": "Abilities guide allowed operations.", "input": "Ability constraints allow VM to:", "output": "Ensuring generics are used safely"}
{"instruction": "Abilities define allowed ops.", "input": "If a resource has `copy` ability, the VM would allow:", "output": "Copying is allowed if `copy` is present"}
{"instruction": "Safety is guaranteed by verification.", "input": "The VM ensures that even if a developer tries to craft malicious bytecode:", "output": "Malicious or invalid bytecode is rejected"}
{"instruction": "Predictability is key for users.", "input": "Move VM\u2019s execution cost model being stable is crucial because:", "output": "Predictable costs build trust and usability"}
{"instruction": "No external I/O ensures determinism.", "input": "The VM prohibits external side-effects because:", "output": "Deterministic execution mandated"}
{"instruction": "Preventing cycles and infinite recursion in type system.", "input": "The verifier ensures no infinite loops caused by `borrow_global` references because:", "output": "No recursive type structures that enable infinite loops"}
{"instruction": "Must exist or `exists` check first.", "input": "If a transaction script tries to read a resource that\u2019s not published yet:", "output": "Accessing non-existent resource aborts"}
{"instruction": "Strong static guarantees aid verification.", "input": "The VM\u2019s strict type system and resource rules allow formal verification tools to:", "output": "Verification becomes feasible"}
{"instruction": "Address-based uniqueness enforces correctness.", "input": "If a resource is published under an address and a module tries to `move_from` another address:", "output": "Must access correct address"}
{"instruction": "Less complexity -> easier verification.", "input": "The VM\u2019s design as a minimalistic bytecode interpreter helps:", "output": "Simplicity aids security and auditability"}
{"instruction": "Everyone agrees on outcomes.", "input": "For a large-scale DeFi protocol, the VM\u2019s determinism:", "output": "Deterministic final states ensure trust and consensus"}
{"instruction": "Ability checks at usage time.", "input": "If a generic struct is instantiated with a type missing `store` ability but stored globally:", "output": "Enforced at runtime attempts"}
{"instruction": "Without external calls, re-entrancy is minimized.", "input": "The VM and Move language aim to reduce the risk of re-entrancy attacks by:", "output": "No external calls = no re-entrancy"}
{"instruction": "Safe memory model.", "input": "Since the VM disallows arbitrary pointer arithmetic:", "output": "Eliminating classes of memory errors"}
{"instruction": "Complex atomic operations possible.", "input": "The VM\u2019s transaction model lets multiple modules be invoked by one script because:", "output": "Multiple calls allowed in a single transaction"}
{"instruction": "Confidence in correctness is vital for DeFi and similar.", "input": "Formal methods can prove that a given set of VM executions maintain invariants. This high assurance is critical for:", "output": "High-stakes smart contracts"}
{"instruction": "Data race impossible with these rules.", "input": "The VM ensures no data races by:", "output": "Single-threaded + exclusive refs prevent races"}
{"instruction": "Phantom generic parameters checked statically.", "input": "If a module defines a phantom type parameter, the VM:", "output": "Phantom types influence compile-time checks only"}
{"instruction": "All modules must be present and consistent.", "input": "In a scenario with layered modules (one module depends on another), the VM\u2019s linking ensures:", "output": "Strict dependency resolution"}
{"instruction": "Deterministic performance model.", "input": "The VM avoids performance shortcuts that might break determinism. For example:", "output": "Must ensure same results regardless of node environment"}
{"instruction": "Verifier prevents illegal casts.", "input": "If a transaction tries an illegal type cast (not possible in Move), the VM:", "output": "Illegal casts can\u2019t appear in verified code"}
{"instruction": "Big updates are possible but costly.", "input": "To handle large-scale state, the VM:", "output": "Gas and time scale with size"}
{"instruction": "Minimalism aids formal methods.", "input": "The VM\u2019s instruction set is kept minimal also to:", "output": "Less complexity aids verification"}
{"instruction": "Must meet constraints at instantiation.", "input": "If a function is generic over T and T must have `key` and `store`, the VM:", "output": "Ability checks ensure correct usage"}
{"instruction": "Prevents silent data loss.", "input": "The VM ensures no accidental integer downcasts by requiring explicit conversion functions, meaning:", "output": "Must use explicit functions that abort on overflow"}
{"instruction": "Memory management by type system.", "input": "Without a garbage collector, the VM:", "output": "Linear logic avoids memory leaks or GC need"}
{"instruction": "u64 is a primitive with `store` ability.", "input": "If a struct is defined as `struct S<T: store> { x: T }` and you try `move_to<S<u64>>(addr, s)`:", "output": "`u64` has store, so `S<u64>` can be stored"}
{"instruction": "Determinism facilitates parallelization outside VM.", "input": "The VM\u2019s deterministic approach aids sharding or parallel execution at a higher level because:", "output": "Predictable behavior supports scaling strategies"}
{"instruction": "Error handling done by abort codes.", "input": "If a script does not handle errors, the VM:", "output": "`abort` ends execution"}
{"instruction": "Verification ensures resource correctness statically.", "input": "Formal verification can ensure no partial resource moves occur by:", "output": "Specs + proving linear usage"}
{"instruction": "Mut and immut borrows can\u2019t coexist.", "input": "If a module tries to `borrow_global_mut` while an immutable borrow of the same resource exists:", "output": "Borrow rules forbid this at verification"}
{"instruction": "Independent component easily integrated.", "input": "To support multiple blockchain platforms, the VM:", "output": "Platform-agnostic design"}
{"instruction": "No partial commits.", "input": "If a transaction tries a huge vector operation and runs out of gas:", "output": "Gas exhaustion = abort"}
{"instruction": "Strict rules = easier reasoning.", "input": "The VM\u2019s strict rules allow compilers or developers to:", "output": "Predictable correctness"}
{"instruction": "u64: copy and drop by default.", "input": "If `fun f<T: drop>(x: T)`, and T = `u64`, calling f:", "output": "Primitives like u64 are drop-able"}
{"instruction": "Eliminating unsafe pointers prevents many vulnerabilities.", "input": "The VM\u2019s memory model, free of unsafe pointers, ensures no:", "output": "Safe from pointer-based attacks"}
{"instruction": "Well-formed struct definitions checked by verifier.", "input": "If a developer tries to define a struct with duplicate field names:", "output": "Struct must have unique field names"}
{"instruction": "Deterministic final states essential for consensus.", "input": "The VM\u2019s deterministic final state ensures that transaction results:", "output": "Identical results -> same hash -> consensus"}
{"instruction": "Private fields not accessible outside module.", "input": "If a module tries to access a private field of a struct defined in another module:", "output": "Enforced privacy at verification"}
{"instruction": "Matching semantics ensures trust in proofs.", "input": "Developers can write formal specs that the Move Prover checks, and the VM\u2019s defined semantics ensure:", "output": "The Prover relies on VM semantics"}
{"instruction": "Resource must be returned or borrow ended first.", "input": "If code tries to `borrow_global_mut<T>` and then `move_from<T>` the same resource before returning the mut ref:", "output": "Borrow rules forbid removal during borrow"}
{"instruction": "Standardized bytecode fosters ecosystem.", "input": "The VM\u2019s architecture lets different Move compilers/IDEs/tools:", "output": "Unified target for ecosystem tools"}
{"instruction": "Struct construction strictly checked.", "input": "If a module tries to `pack` a struct with wrong field order or missing fields:", "output": "Exact layout required"}
{"instruction": "Prevents data loss errors.", "input": "The VM\u2019s checking of numeric conversions ensures no silent truncation by:", "output": "Aborts on out-of-range casts"}
{"instruction": "Simpler model for correctness.", "input": "No dynamic dispatch or inheritance in the VM means:", "output": "Static resolution of all calls"}
{"instruction": "Gas ensures resource limits.", "input": "If a transaction tries complex logic and hits the gas limit:", "output": "Atomic abort on out-of-gas"}
{"instruction": "Namespaces prevent conflicts.", "input": "The VM\u2019s strict module system and address-based naming ensures:", "output": "Address::Module uniqueness"}
{"instruction": "No hidden global vars.", "input": "With no global mutable variables (only global storage under addresses), the VM:", "output": "State is explicit in global storage"}
{"instruction": "assert leads to abort on failure.", "input": "If code tries to `assert(false, code)`, the VM:", "output": "Assertion failure aborts execution"}
{"instruction": "Clear rules = easier tooling.", "input": "Move VM\u2019s design facilitates static analysis tools because:", "output": "Simplicity aids tool developers"}
{"instruction": "Ensures uniqueness.", "input": "The VM ensures global uniqueness of resources by type and address at runtime by:", "output": "Checks `exists<T>(addr)` before `move_to`"}
{"instruction": "VM keeps error mechanism minimal.", "input": "Without exceptions or try-catch, error handling:", "output": "Simple abort mechanism"}
{"instruction": "Strict ability checking.", "input": "If a transaction tries to `move_to` a resource type lacking `store`:", "output": "`store` ability required for global storage"}
{"instruction": "No reinterpretation of bits as another type.", "input": "Ensuring no runtime type confusion means:", "output": "Strict type system prevents type punning"}
{"instruction": "Prevents double-spend or duplication.", "input": "The VM\u2019s deterministic resource model underpins token standards because:", "output": "Resource discipline perfect for token-like assets"}
{"instruction": "Strong correctness guarantees.", "input": "The VM\u2019s design allows formal methods to prove not only functional correctness but also:", "output": "High-level invariants proven via specs"}
{"instruction": "Struct operations must match definition.", "input": "If code tries to `unpack` a struct into fewer variables than fields:", "output": "Exact field matching required"}
{"instruction": "Safe by construction.", "input": "The VM\u2019s static checks ensure no function returns references to dead locals by:", "output": "Impossible to produce verified bytecode with dangling refs"}
{"instruction": "Old code stays, new code at new addresses.", "input": "Since modules are immutable, upgrades require new modules at new addresses:", "output": "Versioning by deploying new modules"}
{"instruction": "Move chosen constraints ensure verification is polynomial.", "input": "Verification complexity is polynomial in code size because:", "output": "Designed for efficient verification"}
{"instruction": "Identical input = identical output.", "input": "If multiple transactions execute the same code with same inputs and global state:", "output": "Pure determinism"}
{"instruction": "All state/logic on-chain ensures clarity.", "input": "Without external dependencies, developers must encode all logic in Move code and global storage. This:", "output": "Transparency and explicitness"}
{"instruction": "Perfect for DeFi and critical apps.", "input": "The VM\u2019s careful design of references, abilities, and global storage operations results in a system where:", "output": "Enables secure complex apps"}
{"instruction": "Core goal of Move VM design.\n\nBelow are questions 801\u20131000 focusing on **Formal Verification** in Move. As before, each question includes difficulty tags, category, four multiple-choice options, the correct answer, and a brief explanation.\n\n**Difficulty distribution for Formal Verification:**  \n- 801\u2013850: Easy  \n- 851\u2013900: Medium  \n- 901\u20131000: Hard\n\n---\n\n### Formal Verification (801\u2013850: Easy)", "input": "Ultimately, the Move VM provides a secure, deterministic, and verifiable execution environment that:", "output": "Foundation for secure blockchain applications"}
{"instruction": "Formal verification involves mathematically proving that a program adheres to a given specification.", "input": "Formal verification in the context of Move means:", "output": "Proving code correctness using logical proofs"}
{"instruction": "The Move Prover is a formal verification tool designed specifically for Move.", "input": "The Move Prover is a tool that:", "output": "Checks code against formal specs"}
{"instruction": "Unlike testing, formal verification can prove absence of certain classes of errors.", "input": "Formal verification aims to provide:", "output": "High confidence in correctness"}
{"instruction": "`spec` syntax allows expressing correctness properties.", "input": "A specification in Move is often written using `spec` blocks that:", "output": "Define formal properties to verify"}
{"instruction": "SMT (Satisfiability Modulo Theories) solvers check logical conditions.", "input": "The Move Prover uses the specifications to:", "output": "Translates specs into logical conditions proven by solvers"}
{"instruction": "Success means the verifier found no counterexamples to the specs.", "input": "If a proof by the Move Prover succeeds, it means:", "output": "Code meets specified correctness conditions"}
{"instruction": "Counterexample demonstrates a failure of the claimed property.", "input": "If the Move Prover finds a counterexample:", "output": "A scenario that breaks the spec exists"}
{"instruction": "Formal proof prevents costly errors in critical contracts.", "input": "Formal verification is especially useful for:", "output": "Financial and security-sensitive logic"}
{"instruction": "`spec` conditions do not run at runtime; they are verified mathematically.", "input": "`assert(cond, code)` in Move runtime differs from formal `spec` assertions because:", "output": "`assert` = runtime check, `spec` = verification-time check"}
{"instruction": "They guarantee certain properties about the function\u2019s final state.", "input": "A postcondition in a `spec fun` block ensures:", "output": "Postconditions describe final state after successful execution"}
{"instruction": "Verification assumes preconditions are true for proof.", "input": "A precondition in a `spec fun` block ensures:", "output": "Limits the scenarios to those where preconditions hold"}
{"instruction": "Invariants describe global truths that never break.", "input": "Invariants are properties that:", "output": "Always true for all reachable states"}
{"instruction": "It checks all possible paths within specified assumptions.", "input": "Formal verification can find bugs that:", "output": "Verification is exhaustive within the given logical framework"}
{"instruction": "It takes Move source plus specifications as input.", "input": "The Move Prover is integrated with Move language by:", "output": "Prover understands Move modules and their specs"}
{"instruction": "If assumptions are violated, proofs may not hold.", "input": "A verified property can fail at runtime if:", "output": "Formal verification is conditional on assumptions (e.g., correct input)"}
{"instruction": "Module invariants define broad, always-true conditions.", "input": "`spec module { ... }` can define module-level invariants that:", "output": "Module-level invariants must hold universally"}
{"instruction": "Automated theorem proving behind the scenes.", "input": "The Move Prover uses backends like SMT solvers (e.g., Z3) to:", "output": "SMT solver tries to prove or disprove conditions"}
{"instruction": "Global invariants describe perpetual truths about storage.", "input": "A `global invariant` in a `spec` ensures:", "output": "Conditions that hold for global state"}
{"instruction": "If you specify it, prover checks it.", "input": "Formal verification can prevent:", "output": "Ensures compliance with logically stated safety properties"}
{"instruction": "Undecidable cases may lead to inconclusive results.", "input": "If the prover times out or cannot determine correctness:", "output": "Sometimes proofs need more hints or are too complex"}
{"instruction": "Testing is partial; verification is logical proof.", "input": "Formal verification differs from testing because:", "output": "Verification is exhaustive given assumptions"}
{"instruction": "`ensures` states what must be true after the function returns.", "input": "`ensures` keyword in `spec fun` block introduces:", "output": "Postcondition"}
{"instruction": "`requires` states conditions that must hold before function call.", "input": "`requires` keyword in `spec fun` block introduces:", "output": "Precondition"}
{"instruction": "Not mandatory, but strongly recommended for critical code.", "input": "Formal verification in Move is optional, meaning:", "output": "Specs are added by choice, Prover is a separate step"}
{"instruction": "Needed for strong invariants.", "input": "Spec language allows quantifiers like `forall` to:", "output": "`forall` states a property for all elements"}
{"instruction": "Formal specs can forbid aborts unless specified.", "input": "The Move Prover checks both function correctness and:", "output": "It can verify no unexpected abort occurs"}
{"instruction": "Prover transforms code+spec into VCs for the SMT solver.", "input": "Verification conditions (VCs) are:", "output": "VCs are proof obligations solver must discharge"}
{"instruction": "Specs guide what properties to check.", "input": "If no specs are written for a function:", "output": "Without specs, not much to verify"}
{"instruction": "Garbage in, garbage out.", "input": "Formal verification is not a silver bullet because:", "output": "If specs are incomplete or wrong, verification can miss errors"}
{"instruction": "The Prover checks all paths to confirm `result >= 0`.", "input": "Simple properties like ensuring a return value is always non-negative can be proven by:", "output": "Postcondition ensures result property"}
{"instruction": "This clarifies expected abort conditions.", "input": "Abort conditions can be specified using `abort_if` in specs to:", "output": "Allowed abort scenarios can be formally stated"}
{"instruction": "Verification of resource discipline is possible with proper specs.", "input": "The prover helps ensure resource linearity by:", "output": "If you specify linear usage conditions, prover can confirm no illegal moves"}
{"instruction": "Good specs = meaningful verification results.", "input": "Writing good specs involves:", "output": "High-quality specs improve proof coverage"}
{"instruction": "Counterexamples help diagnose spec failures.", "input": "The Move Prover reports results like:", "output": "It indicates success or shows a counterexample"}
{"instruction": "Counterexamples pinpoint where assumptions fail.", "input": "If the prover finds a counterexample:", "output": "Adjust code or specs to remove the found violation"}
{"instruction": "Both help ensure correctness.", "input": "Formal verification complements testing by:", "output": "They serve different roles; verification is exhaustive logically"}
{"instruction": "`spec` language adds formal property declarations.", "input": "Specifications are written in special `spec` language that:", "output": "Logical layer on top of Move code"}
{"instruction": "Verification = correctness assurance.", "input": "The goal of formal verification is to:", "output": "Guarantee correctness per specs"}
{"instruction": "Verification reduces risk of hidden bugs.", "input": "If no formal verification is done, code can still be deployed but:", "output": "Without verification, undetected errors may remain"}
{"instruction": "Prover checks all code paths for abort.", "input": "To prove something like \u201cfunction never aborts\u201d:", "output": "A specification stating no abort conditions allowed"}
{"instruction": "Verification is an iterative process.", "input": "A common step after writing specs is to:", "output": "Iterative refinement is common"}
{"instruction": "Formal properties can rule out overflow.", "input": "The Move Prover can also check arithmetic properties like:", "output": "If specs state no overflow allowed, prover checks it"}
{"instruction": "They guarantee stable conditions globally.", "input": "Invariants can be module-level or resource-level to:", "output": "Invariants ensure stable properties at all times"}
{"instruction": "More complex code \u2192 more elaborate specs.", "input": "Verifying complex contracts might require:", "output": "Complex logic often needs more detailed specs and lemmas"}
{"instruction": "Sometimes compromises are needed.", "input": "If a property cannot be proven due to complexity:", "output": "Adjust approach to ensure tractability"}
{"instruction": "High assurance in correctness.", "input": "Formal verification increases developer confidence in:", "output": "Reduces risk of critical bugs"}
{"instruction": "Proofs depend on a fixed code base.", "input": "Once proven, properties remain valid unless:", "output": "Modifying code/spec can invalidate proofs"}
{"instruction": "`spec var` defines logical variables for specs.", "input": "`spec var` can define symbolic constants or state predicates used in specs:", "output": "Aids in readability and abstraction"}
{"instruction": "They pinpoint exactly what went wrong.", "input": "Prover output often includes counterexamples with assignments to variables:", "output": "Counterexamples help developers understand the failure scenario"}
{"instruction": "Verification is only as good as the specs.\n\n---\n\n### Formal Verification (851\u2013900: Medium)", "input": "One must remember formal verification proves correctness relative to:", "output": "If specs are incomplete, verification doesn\u2019t guarantee full correctness"}
{"instruction": "Formal methods rely on theorem proving/SMT solvers.", "input": "The Move Prover\u2019s underlying method is:", "output": "Code \u2192 Logical conditions \u2192 SMT solver"}
{"instruction": "Lemmas help structure big proofs.", "input": "To handle code complexity, developers can introduce helper lemmas in specs that:", "output": "Lemmas support modular reasoning"}
{"instruction": "Specs can mention global and local state.", "input": "Pre/postconditions can specify conditions on parameters and returns, as well as:", "output": "They can talk about global state transformations too"}
{"instruction": "Helps differentiate expected abort scenarios from errors.", "input": "An abort condition `abort_if e;` in specs means:", "output": "It declares conditions under which abort is acceptable"}
{"instruction": "Proof ensures no violation of stated logic.", "input": "Formal verification can show absence of certain bugs like:", "output": "Logical/resource-related bugs can be eliminated"}
{"instruction": "Prover ensures no code path breaks this invariant.", "input": "To verify that a resource is never lost, one might specify an invariant ensuring:", "output": "Invariants can ensure resource counts remain stable"}
{"instruction": "It\u2019s exhaustive under the mathematical model.", "input": "The prover checks all code paths because:", "output": "Symbolic reasoning covers infinite states (within limits)"}
{"instruction": "More logic \u2192 more complex verification conditions.", "input": "Verification complexity can grow with:", "output": "Larger code, more complex specs = harder proofs"}
{"instruction": "Iteration until proofs succeed.", "input": "If the prover fails to verify a property, developers can:", "output": "Adjusting the verification approach often helps"}
{"instruction": "Specifications describe what must always hold, abstractly.", "input": "Formal methods may require developers to think more abstractly about code:", "output": "High-level reasoning about all possible states"}
{"instruction": "Simpler logic is easier to verify.", "input": "Some properties can be proven easier if the code:", "output": "Clean code helps proofs"}
{"instruction": "Abilities also inform verification conditions.", "input": "The Move Prover understands Move\u2019s type system and abilities, meaning:", "output": "Prover is aware of Move\u2019s semantics, including abilities"}
{"instruction": "The prover checks arithmetic constraints too.", "input": "When verifying no overflow, you might write specs like:", "output": "Bounds in specs let prover ensure arithmetic stays in range"}
{"instruction": "Ghost variables represent conceptual data for proof.", "input": "Ghost variables in specs (`spec var`) allow:", "output": "Extra logical helpers for proofs"}
{"instruction": "The prover relies on defined invariants for loops.", "input": "Termination is generally assumed in the Move Prover because:", "output": "Loops must be handled with invariants or be finite by design"}
{"instruction": "Without invariants, loops are hard to verify.", "input": "For loops, one must provide loop invariants that:", "output": "Loop invariants guide the prover through iterative reasoning"}
{"instruction": "Prover can only use what\u2019s declared.", "input": "If a function\u2019s correctness depends on a global invariant:", "output": "Invariants must be stated explicitly for the prover"}
{"instruction": "Developers just write specs; prover does the rest.", "input": "Translating Move code to logical formulas is done automatically by:", "output": "The toolchain automates this process"}
{"instruction": "Verification is iterative and involves refinement.", "input": "Debugging verification failures involves:", "output": "Counterexamples guide debugging"}
{"instruction": "Invariants can restrict resource removal.", "input": "If a resource must never be `move_from` a certain address once published:", "output": "Prover ensures no code path violates it"}
{"instruction": "Logical complexity scales with code complexity.", "input": "The complexity of the proof depends on:", "output": "More complex logic or stricter specs = harder proofs"}
{"instruction": "Lemmas break down complex proofs.", "input": "Some properties might require inductive reasoning or lemmas because:", "output": "Complex properties need supporting lemmas"}
{"instruction": "Inlining might simplify or complicate proofs.", "input": "The Move Prover\u2019s `spec inline` or `spec opaque` features can:", "output": "Fine-tune proof strategies"}
{"instruction": "No low-level memory issues to prove.", "input": "Memory models in verification are simplified:", "output": "Abstract reference model aids proofs"}
{"instruction": "Dependencies must be available for global reasoning.", "input": "When verifying a cross-module property, the prover needs:", "output": "It must see all definitions and invariants"}
{"instruction": "After code is stable, add specs and prove correctness.", "input": "Prover integration in the development workflow:", "output": "Typically a later quality step"}
{"instruction": "Complex proofs need more effort.", "input": "Some desired properties may be too hard to prove automatically because:", "output": "Complex properties need careful specification and possibly manual lemmas"}
{"instruction": "Verification is relative to the model and specs.", "input": "If the prover finds no counterexamples and completes successfully:", "output": "Proof holds under stated conditions"}
{"instruction": "Outside domain not proven.", "input": "One limitation of formal verification is that it does not account for:", "output": "Only what\u2019s modeled and specified is checked"}
{"instruction": "Strength of specs = meaningfulness of verification.", "input": "If specs are too weak (not stating enough conditions):", "output": "A trivial proof: no constraints to violate"}
{"instruction": "Detailed specs = more rigorous proofs.", "input": "Strengthening specs by adding more detailed conditions:", "output": "More constraints = deeper correctness checks"}
{"instruction": "Unreachable code might lead to trivially satisfied conditions or contradictions.", "input": "Verification can detect unreachable code or dead paths if specs consider such conditions:", "output": "Logical contradictions show unreachable code"}
{"instruction": "Prover checks no code path removes that resource.", "input": "If a resource must remain in global storage after a function call, you specify:", "output": "`ensures` conditions describe unchanged resource state"}
{"instruction": "Automated verification in CI = consistent quality.", "input": "The Move Prover can be integrated into CI pipelines:", "output": "Continuous verification ensures ongoing correctness"}
{"instruction": "Ensures invariants hold through state transitions.", "input": "Some invariants require `invariant update` syntax:", "output": "`invariant update` checks conditions around storage changes"}
{"instruction": "Perfect is enemy of good; partial specs might still help.", "input": "Complexity in verification sometimes leads to trade-offs like:", "output": "Balance detail vs. provability"}
{"instruction": "They don\u2019t appear in runtime code, just in proofs.", "input": "Ghost functions in specs allow:", "output": "Pure logical helpers"}
{"instruction": "Formalize secrecy invariants.", "input": "Ensuring no secret keys leak can be modeled if:", "output": "If you can specify what \"leak\" means, prover checks it"}
{"instruction": "Non-linear arithmetic is notoriously hard for SMT.", "input": "The prover\u2019s SMT solver might struggle with non-linear arithmetic or complex data structures, meaning:", "output": "Simplify problem for solver feasibility"}
{"instruction": "Verification performance tuning is often needed.", "input": "If verification takes too long, you can:", "output": "Optimization or pruning complexity helps"}
{"instruction": "Specs are formal, unambiguous documentation.", "input": "Specifications also serve as documentation because:", "output": "Future readers can understand design intentions"}
{"instruction": "Unspecified behaviors remain unchecked.", "input": "One caveat of formal verification is that it does not prove:", "output": "Only specified properties are checked"}
{"instruction": "Proof depends on assumptions.", "input": "Even if formally verified, code can fail if:", "output": "Assumptions must hold in reality"}
{"instruction": "The prover checks vector properties per specs.", "input": "When verifying a function that manipulates vectors, invariants might specify:", "output": "Ensuring no out-of-bound or incorrect values"}
{"instruction": "Formal tools evolve rapidly.", "input": "The Move Prover is evolving, meaning:", "output": "Expect ongoing improvements"}
{"instruction": "Without modeling, prover can\u2019t reason about it.", "input": "A challenging aspect is modeling all relevant aspects:", "output": "You must explicitly model all needed properties"}
{"instruction": "Prover checks all code paths for exceeding N.", "input": "Verifying a property like \u201cno more than N tokens minted\u201d involves:", "output": "Invariants ensure token count limits"}
{"instruction": "Partial specs mean partial assurances.", "input": "If verification is partial (only some functions have specs):", "output": "Unspecified parts are not guaranteed correct"}
{"instruction": "Developer involvement is key.", "input": "The Move Prover user must:", "output": "An iterative, human-driven process"}
{"instruction": "Critical for security and trust.\n\n---\n\n### Formal Verification (901\u20131000: Hard)", "input": "Ultimately, formal verification in Move:", "output": "It\u2019s a strong tool to prevent costly bugs"}
{"instruction": "Move Prover primarily focuses on safety properties.", "input": "Proving liveness properties (something good eventually happens) is harder than safety (nothing bad happens) because:", "output": "Liveness = temporal reasoning, more complex"}
{"instruction": "Termination proofs need more advanced specs.", "input": "To prove termination of loops, you might need:", "output": "Variant functions show progress towards termination"}
{"instruction": "Complex math properties need more elaborate proof support.", "input": "Complex algebraic properties might require:", "output": "Step-by-step logical lemmas"}
{"instruction": "Simplified models aid verification clarity.", "input": "Higher-level abstractions in specs can help:", "output": "Abstractions make proofs more manageable"}
{"instruction": "Handling universal quantification is non-trivial.", "input": "If a property involves quantification over large domains (like \u201cfor all accounts\u201d):", "output": "Universal quantification is complex; ghost variables or carefully chosen predicates help"}
{"instruction": "Such proofs are more intricate than simple postconditions.", "input": "Proving refinement (i.e., one implementation refines another) might require:", "output": "Complex relational reasoning between two systems"}
{"instruction": "Expert-level tuning often needed.", "input": "Prover performance issues (timeouts) can be addressed by:", "output": "Techniques like triggers, hints, and decomposition improve solver performance"}
{"instruction": "Reducing solver complexity is key.", "input": "Non-linear integer arithmetic (like multiplication by variables) is notoriously hard for SMT solvers, so:", "output": "Simplify arithmetic or add tailored lemmas"}
{"instruction": "Without a model, prover can\u2019t reason about them.", "input": "Verifying properties that depend on interaction with external modules not fully specified:", "output": "Model external modules abstractly"}
{"instruction": "Re-entrancy proofs need careful global invariants.", "input": "To prove no re-entrancy, if external calls were allowed, you\u2019d specify:", "output": "Formal invariants forbidding unintended re-entry states"}
{"instruction": "Inductive invariants are crucial for loops and recurring patterns.", "input": "Some proofs require inductive invariants that:", "output": "Inductive invariants prove correctness for all states via induction"}
{"instruction": "Every function must preserve the invariant.", "input": "To prove something like \u201cno account\u2019s balance ever goes negative,\u201d you:", "output": "A global invariant plus verifying all state changes maintain non-negativity"}
{"instruction": "Proof relies on general properties, not per-element check.", "input": "Handling large data structures (e.g., big vectors) symbolically means:", "output": "Symbolic reasoning + invariants about elements"}
{"instruction": "Invariants can be guarded by conditions.", "input": "If certain invariants are conditional (hold only when a certain flag is set), you must:", "output": "Conditional invariants reflect state-dependent properties"}
{"instruction": "Complex domains need carefully structured proofs.", "input": "Complex monetary policies involving multiple resources and exchange rates might require:", "output": "Multiple layered invariants and steps"}
{"instruction": "Solver needs guidance for quantifier instantiation.", "input": "If prover fails due to quantifier instantiation issues, you can:", "output": "Add triggers or simplify quantifiers"}
{"instruction": "Divide and conquer strategy.", "input": "Some advanced proofs might benefit from modular reasoning, meaning:", "output": "Modular approach reduces complexity"}
{"instruction": "This ensures invariant\u2019s global stability.", "input": "To show an invariant holds after all possible updates, you must consider:", "output": "Invariant must be preserved by all state transitions"}
{"instruction": "Existential proofs can be tricky.", "input": "If a spec involves existential quantifiers (`exists`), it\u2019s often harder because:", "output": "Finding a suitable witness is challenging for the solver"}
{"instruction": "Requires specifying how states of both programs relate.", "input": "Proving equivalence of two different implementations might require:", "output": "Relational reasoning is more complex"}
{"instruction": "SMT solvers reason symbolically about infinite sets.", "input": "To handle infinite domains, the solver relies on:", "output": "Pure logical reasoning with no brute force"}
{"instruction": "Scalability requires smart proof strategies.", "input": "If verification is too slow or memory-heavy, you might:", "output": "Decompose problem for efficiency"}
{"instruction": "Formal methods rely on tool soundness.", "input": "Soundness of the prover means:", "output": "Sound = no false positives given correct assumptions"}
{"instruction": "Trust but verify toolchain.", "input": "In rare cases, solver bugs or SMT logic incompleteness might cause:", "output": "Tools are complex; bugs happen"}
{"instruction": "Every update must preserve monotonicity.", "input": "To prove a monotonic property (like a counter never decreases), specify:", "output": "Invariants and function specs ensuring no decrease"}
{"instruction": "Formal verification of crypto is complex, often done at abstract level.", "input": "When verifying cryptographic properties (if modeled), you must:", "output": "Represent cryptographic primitives abstractly"}
{"instruction": "No model = no reasoning about external I/O.", "input": "The prover can\u2019t handle non-deterministic external I/O:", "output": "Must model external behavior in specs"}
{"instruction": "Realistic approach: verify critical properties.", "input": "Achieving full functional correctness (proving code does exactly the right thing for all inputs) can be:", "output": "Full correctness is a big task"}
{"instruction": "All relevant modules must be known to prover.", "input": "Verifying invariants that span multiple modules and resources requires:", "output": "Cross-module invariants need a holistic approach"}
{"instruction": "Less complexity = easier proof.", "input": "If a proof is too complex, developers might:", "output": "Code simplification often helps verification"}
{"instruction": "If invariants can\u2019t be broken, no leak occurs.", "input": "To prove no secret resource leak, you might specify invariants stating:", "output": "Resource invariants ensure no unauthorized changes"}
{"instruction": "Higher-order means more complexity.", "input": "Some higher-order reasoning (functions as arguments) is not in Move, but if it were, verification:", "output": "Higher-order logic is more complex for SMT"}
{"instruction": "Formal verification is about correctness, not runtime performance.", "input": "Verification cannot guarantee performance properties (like time complexity) because:", "output": "Prover checks correctness, not performance"}
{"instruction": "Global correctness requires all transitions to maintain conditions.", "input": "If invariants need to hold after any transaction sequence, you must ensure:", "output": "Every operation must preserve invariants"}
{"instruction": "Uninterpreted functions represent black-box logic.", "input": "Introducing uninterpreted functions in specs can help by:", "output": "Abstraction reduces complexity"}
{"instruction": "Non-linear modular arithmetic is tricky for SMT.", "input": "If a property depends on arithmetic modulo large primes (common in crypto), the solver:", "output": "Complex arithmetic needs careful guidance"}
{"instruction": "Invariants must remain intact after code changes.", "input": "To prove backward compatibility of a new module version:", "output": "Re-verify invariants with the new code"}
{"instruction": "Most SMT-based solvers are not complete; they can miss some truths.", "input": "Soundness means if the prover says \u201cno counterexample,\u201d there truly is none at that abstraction level. Completeness means:", "output": "Completeness ensures it finds all true properties"}
{"instruction": "Focus on key invariants first.", "input": "Many verification frameworks accept partial specifications:", "output": "Partial coverage is still beneficial"}
{"instruction": "Even unused lemmas can clarify design intentions.", "input": "If a lemma is not used by any proof, it can still help by:", "output": "Lemmas also serve as documentation"}
{"instruction": "Verification encourages stable, well-structured designs.", "input": "Strong specs can limit code evolution because:", "output": "Rigid specs enforce stable design choices"}
{"instruction": "Loops + invariants = provable correctness.", "input": "To handle stateful iterations, you might define:", "output": "Iteration invariants ensure correct state progression"}
{"instruction": "Manual guidance often needed.", "input": "In the face of solver incompleteness, sometimes you must:", "output": "More hints to solver"}
{"instruction": "Model all assumptions explicitly.", "input": "Verification might miss environmental constraints not stated in specs, so:", "output": "If not stated, not verified"}
{"instruction": "Divide and conquer.", "input": "For a large codebase, scaling verification involves:", "output": "Compositional verification is crucial"}
{"instruction": "Similar to proving correctness of recursive functions.", "input": "Proving properties over recursively defined data structures (if Move had them) would require:", "output": "Induction is key for recursive structures"}
{"instruction": "Necessitates checking each function maintains that invariant.", "input": "If a certain condition must hold after all possible sequences of function calls, you prove:", "output": "Stability across all transitions"}
{"instruction": "Advanced modeling needed for sophisticated properties.", "input": "Some intricate properties (like resource cycling) may require:", "output": "Complex modeling techniques"}
{"instruction": "Triggers decide how quantifiers are used.", "input": "If the prover fails due to quantifier instantiation, adding manual triggers:", "output": "Trigger hints guide the solver"}
{"instruction": "Predicates modularize specs.", "input": "Custom predicates defined in specs can encapsulate complex conditions:", "output": "Reusable abstractions for clarity"}
{"instruction": "Ensures no invalid calls happen in proofs.", "input": "To handle partial functions (functions not defined for all inputs), specify:", "output": "Preconditions narrow the function\u2019s valid input space"}
{"instruction": "Keep track of sums and prove stable.", "input": "Verifying intricate arithmetic invariants (like maintaining a balance sum across accounts) involves:", "output": "Declare an invariant about total sum and show all ops preserve it"}
{"instruction": "Everything must be specified if not natively handled.", "input": "If the code uses bitwise operations or special low-level ops (not common in Move), verifying them would:", "output": "Complex or custom logic might need explicit modeling"}
{"instruction": "Prover may fail to prove a true property due to complexity.", "input": "Soundness means no false positives. But what about false negatives? If prover can\u2019t find a proof:", "output": "Incompleteness can cause false negatives"}
{"instruction": "Translate real-world concepts into formal invariants.", "input": "Some complex domain properties (like liquidity constraints in finance) may require:", "output": "Domain modeling in logic form"}
{"instruction": "Lemmas break complex proofs into smaller steps.", "input": "Lemma functions in specs can:", "output": "Building blocks for complex proofs"}
{"instruction": "They reveal hidden corner cases.", "input": "If an invariant fails only under very complex conditions, the prover\u2019s counterexample:", "output": "Counterexamples can be complex but enlightening"}
{"instruction": "Decompose big proofs into smaller verified parts.", "input": "If verifying a large system is too hard at once, a strategy is:", "output": "Modular verification scales better"}
{"instruction": "Prover checks no code path violates immutability.", "input": "Ensuring no secret value changes unintentionally might require:", "output": "Explicit invariants about that value\u2019s immutability"}
{"instruction": "Without built-in theory, must provide specs.", "input": "Handling sets or maps (if Move had them) would need:", "output": "To prove properties about complex data structures, define their logical theory"}
{"instruction": "Fractional arithmetic invariants are tricky.", "input": "If a resource distribution property involves complex arithmetic (like fractional shares), verifying no misallocation might:", "output": "More complex arithmetic reasoning"}
{"instruction": "Perfect proofs might be too hard, settle for partial.", "input": "Sometimes developers need to choose between proving a property fully or:", "output": "Trade-offs in property strength vs. verifiability"}
{"instruction": "Smaller search space = faster proof.", "input": "If the solver struggles with boolean combinations, adding symmetry-breaking conditions or simpler forms can:", "output": "Simplifying logic helps solver"}
{"instruction": "That\u2019s how safety properties are proven over infinite executions.", "input": "To show an invariant holds \u201cfor all future states,\u201d you rely on:", "output": "Inductive invariants"}
{"instruction": "Real-world failures not modeled = not verified.", "input": "Verification can\u2019t handle physical-layer constraints (like \u201cif hardware fails\u201d) because:", "output": "Outside the specified logical domain"}
{"instruction": "It can prove properties independent of actual key value.", "input": "If crypto keys are modeled as uninterpreted constants:", "output": "Abstract modeling of secrets"}
{"instruction": "Spec language may have limitations.", "input": "Some desired properties might not be expressible easily in current Move spec language:", "output": "Sometimes must approximate or simplify properties"}
{"instruction": "Some proof is better than none.", "input": "If verification becomes intractable, scaling down the problem (verifying simpler scenarios) can:", "output": "Partial verification still helps"}
{"instruction": "Tool improvements enhance verification scope.", "input": "In future, more advanced Move Prover features (like custom theories) may allow:", "output": "Extending verifier capabilities"}
{"instruction": "Logical methods represent infinite states symbolically.", "input": "If a property involves infinite state space, the prover relies on:", "output": "Finite abstractions and induction to handle infinity"}
{"instruction": "Manual intervention improves success rate.", "input": "Without user guidance (lemmas/triggers), solver heuristics might fail on complex proofs:", "output": "User guidance often essential"}
{"instruction": "Refinement proofs: code \u2264 specification in behavior.", "input": "Proving refinement (implementation matches specification) can be approached by:", "output": "Show code simulates the abstract model"}
{"instruction": "Help solver understand arithmetic identities.", "input": "Some properties may require non-linear integer reasoning (like `(x+y)*z = x*z + y*z`), the solver:", "output": "Non-linear arithmetic is tough; provide equalities as axioms"}
{"instruction": "If concurrency existed, invariants handle deadlocks.", "input": "To prove absence of deadlocks or concurrency issues (if Move had concurrency):", "output": "In a hypothetical scenario, concurrency invariants needed"}
{"instruction": "Total correctness = partial correctness + termination.", "input": "Partial correctness proves that if a function terminates, it meets specs. For total correctness (including termination), you need:", "output": "Termination arguments included"}
{"instruction": "Contradictions cause proof failure.", "input": "If specs contradict each other (e.g., one invariant says X\u22650, another says X<0 always):", "output": "Inconsistent specs lead to unsatisfiable conditions"}
{"instruction": "Needed to prove equivalence or refinement.", "input": "Verifying differential properties (implementation A vs. B) can be done by:", "output": "Relational specifications for differential reasoning"}
{"instruction": "SMT solver can handle mathematically infinite ints but complexity may increase.", "input": "Handling big integer arithmetic (beyond u128) might need:", "output": "Introduce bounds or treat them as abstract integers"}
{"instruction": "Inductive or clever lemmas needed.", "input": "If a spec requires checking a property on all subsets of a set, you face combinational explosion:", "output": "Logical reasoning must avoid explicit enumeration"}
{"instruction": "Non-determinism = universal quantification over outcomes.", "input": "Non-determinism (if Move had any) would be handled by:", "output": "Must ensure property holds for all outcomes"}
{"instruction": "Higher-level math properties in specs.", "input": "Proving that a function is injective or bijective (if needed) involves:", "output": "Logical conditions representing injectivity/bijectivity"}
{"instruction": "The prover checks the sorting property holds after operations.", "input": "Verifying properties involving ordering of elements (like a sorted vector) would need:", "output": "Detailed invariants for sorting"}
{"instruction": "Solver\u2019s logic is limited, must encode math.", "input": "If certain arithmetic requires prime factoring or complex number theory, the prover:", "output": "Custom axioms/lemmas represent mathematical truths"}
{"instruction": "Pragmatic approach: verify the most important aspects.", "input": "If verification proves too hard, a fallback is:", "output": "Focus on most critical invariants"}
{"instruction": "Complexity in specs can backfire.", "input": "Overly complicated specs can hinder proving because:", "output": "Keep specs as simple and clear as possible"}
{"instruction": "A structured approach to arithmetic proofs.", "input": "To systematically handle arithmetic inequalities, you can define:", "output": "Lemmas break complex inequalities into simpler steps"}
{"instruction": "There are theoretical limitations.", "input": "The Move Prover\u2019s strategy might fail if:", "output": "Some properties are beyond solver\u2019s capacity"}
{"instruction": "Custom modeling for unsupported features.", "input": "In absence of certain features (like floating point), you must:", "output": "Introduce your own logical theory"}
{"instruction": "Every transition must preserve safety.", "input": "Ensuring a state machine defined by multiple transitions remains safe can be done by:", "output": "Inductive invariants covering all transitions"}
{"instruction": "Hard to handle probability in standard SMT.", "input": "If you need probabilistic guarantees, the prover:", "output": "Probability is not native; need logical encodings or assumptions"}
{"instruction": "Common in verifying complex systems.", "input": "Advanced proofs might involve refinement mapping:", "output": "Refinement mappings link code to simpler models"}
{"instruction": "Prover is not omniscient.", "input": "If a known mathematical lemma is needed (like a theorem from number theory), you must:", "output": "Introduce or prove the theorem in specs"}
{"instruction": "Abstraction helps solver handle big problems.", "input": "A strategy to reduce complexity is \u201cabstraction,\u201d meaning:", "output": "Abstracting complexity to manageable core"}
{"instruction": "This ensures perpetual safety.", "input": "If invariants must hold at all observable states (post any function call), the Prover:", "output": "Ensures invariants after every function execution"}
{"instruction": "Like in math proofs, induction is key.", "input": "Some properties require non-trivial induction proofs:", "output": "Classic induction approach"}
{"instruction": "Explicit triggers guide quantifier instantiations.", "input": "Without proper triggers for quantifiers, the solver might never apply those axioms, resulting in:", "output": "Without triggers, quantifiers might remain unused"}
{"instruction": "Complexity demands structured approach.", "input": "Properties mixing arithmetic, resources, and complex logic may require:", "output": "Decompose into manageable chunks"}
{"instruction": "GIGO principle.", "input": "If the verification model differs from reality (e.g., ignoring network failures), proven properties:", "output": "Real-world assumptions must match verification assumptions"}
{"instruction": "Automation is powerful but not omnipotent.", "input": "Achieving fully automated proofs of very complex properties might be unrealistic without:", "output": "Complex proofs need human-guided strategies"}
{"instruction": "The reason we do formal verification.", "input": "Ultimately, formal verification in Move provides:", "output": "Strong correctness guarantees for critical logic"}
